<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1. Nasm指南中文 (NASM Tutorial)英文原文链接：http:&#x2F;&#x2F;cs.lmu.edu&#x2F;~ray&#x2F;notes&#x2F;nasmtutorial&#x2F;中文原文链接：https:&#x2F;&#x2F;github.com&#x2F;zhangjunlei26&#x2F;NASM-Tutorial-CN  NASM 是一个绝赞的汇编器。现在让我们通过一些例子来学习 NASM。 然而这里的笔记仅仅只是蜻蜓点水般地涉及了一些皮毛,所以当你看">
<meta property="og:type" content="article">
<meta property="og:title" content="zhuhui&#39;s yard">
<meta property="og:url" content="http://example.com/2021/07/17/Note/%E7%AC%94%E8%AE%B0/NASM%E6%B1%87%E7%BC%96/Nasm%E6%8C%87%E5%8D%97/index.html">
<meta property="og:site_name" content="zhuhui&#39;s yard">
<meta property="og:description" content="1. Nasm指南中文 (NASM Tutorial)英文原文链接：http:&#x2F;&#x2F;cs.lmu.edu&#x2F;~ray&#x2F;notes&#x2F;nasmtutorial&#x2F;中文原文链接：https:&#x2F;&#x2F;github.com&#x2F;zhangjunlei26&#x2F;NASM-Tutorial-CN  NASM 是一个绝赞的汇编器。现在让我们通过一些例子来学习 NASM。 然而这里的笔记仅仅只是蜻蜓点水般地涉及了一些皮毛,所以当你看">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangjunlei26/NASM-Tutorial-CN/master/assets/nasm-logo.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangjunlei26/NASM-Tutorial-CN/master/assets/nasmstructure.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangjunlei26/NASM-Tutorial-CN/master/assets/rdx.png">
<meta property="article:published_time" content="2021-07-17T13:04:46.830Z">
<meta property="article:modified_time" content="2021-06-19T02:26:15.311Z">
<meta property="article:author" content="朱辉">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhangjunlei26/NASM-Tutorial-CN/master/assets/nasm-logo.png">

<link rel="canonical" href="http://example.com/2021/07/17/Note/%E7%AC%94%E8%AE%B0/NASM%E6%B1%87%E7%BC%96/Nasm%E6%8C%87%E5%8D%97/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | zhuhui's yard</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zhuhui's yard</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/17/Note/%E7%AC%94%E8%AE%B0/NASM%E6%B1%87%E7%BC%96/Nasm%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="朱辉">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhuhui's yard">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-17 21:04:46" itemprop="dateCreated datePublished" datetime="2021-07-17T21:04:46+08:00">2021-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-19 10:26:15" itemprop="dateModified" datetime="2021-06-19T10:26:15+08:00">2021-06-19</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-Nasm指南中文-NASM-Tutorial"><a href="#1-Nasm指南中文-NASM-Tutorial" class="headerlink" title="1. Nasm指南中文 (NASM Tutorial)"></a>1. Nasm指南中文 (NASM Tutorial)</h1><p>英文原文链接：<a target="_blank" rel="noopener" href="http://cs.lmu.edu/~ray/notes/nasmtutorial/">http://cs.lmu.edu/~ray/notes/nasmtutorial/</a><br>中文原文链接：<a target="_blank" rel="noopener" href="https://github.com/zhangjunlei26/NASM-Tutorial-CN">https://github.com/zhangjunlei26/NASM-Tutorial-CN</a></p>
<blockquote>
<p>NASM 是一个绝赞的汇编器。现在让我们通过一些例子来学习 NASM。 然而这里的笔记仅仅只是蜻蜓点水般地涉及了一些皮毛,所以当你看完这个页面后,你需要查看 <a target="_blank" rel="noopener" href="http://www.nasm.us/doc/">官方的 NASM 文档 </a>。</p>
<p>因原文写的时间应该比较早，翻译该文章是在2020年2月2日，一些链接已经不能再打开，有的示例代码在我的MAC OSX Catalina 10.15.3上也无法正常编译通过，笔者上述问题进行了修正（Linux下未进行验证）。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/zhangjunlei26/NASM-Tutorial-CN/master/assets/nasm-logo.png" alt="img"></p>
<h2 id="1-1-教程范围"><a href="#1-1-教程范围" class="headerlink" title="1.1. 教程范围"></a>1.1. 教程范围</h2><p>本教程将向您展示如何在 x86-64 体系结构上编写汇编语言程序。您将同时学会编写：</p>
<ol>
<li>独立运行的汇编程序</li>
<li> 与 C 集成的程序</li>
</ol>
<blockquote>
<p>请注意：教程会涉及Windows/MacOSX/Linux三个系统的使用方法，请确保在其中一个平台下已经安装好 nasm 和 gcc。</p>
</blockquote>
<h2 id="1-2-第一个程序"><a href="#1-2-第一个程序" class="headerlink" title="1.2. 第一个程序"></a>1.2. 第一个程序</h2><p>在学习 nasm 之前,请确保您可以键入并运行程序。</p>
<p>确保同时安装了 nasm 和 gcc。将以下程序之一另存为<code>hello.asm</code>,具体取决于您的计算机平台。然后根据给定的说明运行程序。</p>
<p>如果您使用的是基于 Linux 的操作系统：</p>
<p><code>hello.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line">; 仅使用syscall将&quot;Hello,World&quot;写入控制台。仅在64位Linux上运行。</span><br><span class="line">; 使用 Linux 下的 1 号系统调用来输出一条信息和 60 号系统调用来退出程序。</span><br><span class="line">; 编译汇编代码并运行：</span><br><span class="line">;</span><br><span class="line">; nasm -felf64 hello.asm &amp;&amp; ld hello.o &amp;&amp; ./a.out</span><br><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">          global    _start</span><br><span class="line"></span><br><span class="line">          section   .text</span><br><span class="line">_start:   </span><br><span class="line">         ; write(1, message, 13)</span><br><span class="line">          mov       rax,1                  ; 1 号系统调用是写操作</span><br><span class="line">          mov       rdi,1                  ; 1 号文件系统调用是标准输出stdout</span><br><span class="line">          mov       rsi,message            ; 输出字符串的地址</span><br><span class="line">          mov       rdx,13                 ; 字节数（输出字符串的长度）</span><br><span class="line">          syscall                           ; 调用操作系统进行写入</span><br><span class="line">          </span><br><span class="line">          ; exit(0)</span><br><span class="line">          mov       rax,60                 ; 60号系统调用是退出</span><br><span class="line">          xor       rdi,rdi                ; 退出代码 0</span><br><span class="line">          syscall                           ; 调用操作系统退出</span><br><span class="line"></span><br><span class="line">          section   .data</span><br><span class="line">message:  db        &quot;Hello,World&quot;,10      ; 注意最后的换行符</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -felf64 hello.asm &amp;&amp; ld hello.o &amp;&amp; ./a.out</span></span><br><span class="line">Hello,World</span><br></pre></td></tr></table></figure>



<p>如果您使用的是 macOS：</p>
<p><code>hello.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line">; 仅使用syscall将&quot; Hello,World&quot;写入控制台。仅在64位macOS上运行。</span><br><span class="line">;</span><br><span class="line">; 显示nasm支持的输出格式</span><br><span class="line">; nasm -hf  </span><br><span class="line">;</span><br><span class="line">; 编译汇编代码并运行：</span><br><span class="line">; nasm -fmacho64 hello.asm &amp;&amp; ld -o hello -e _main -lSystem hello.o &amp;&amp; ./hello</span><br><span class="line">; 也可以如下方式运行：</span><br><span class="line">; nasm -fmacho64 hello.asm &amp;&amp; gcc -o hello hello.o &amp;&amp; ./hello</span><br><span class="line">;</span><br><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">section .data</span><br><span class="line">  msg: db &quot;Hello, World!&quot;,10,0   ; 注意最后的换行符</span><br><span class="line">  len: equ $-msg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _main</span><br><span class="line"></span><br><span class="line">; kernel:</span><br><span class="line">;     syscall</span><br><span class="line">;     ret</span><br><span class="line"></span><br><span class="line">_main:</span><br><span class="line">    ; write(1, msg, 13)</span><br><span class="line">    mov rax,0x02000004      ; 系统调用</span><br><span class="line">    mov rdi,1               ; 文件句柄号1是stdout</span><br><span class="line">    mov rsi,msg             ; 要输出的字符串地址</span><br><span class="line">    mov rdx,len             ; 15字节数</span><br><span class="line">    ; exit(0)</span><br><span class="line">    syscall                 ; 调用操作系统进行写入</span><br><span class="line">    ; call kernel</span><br><span class="line"></span><br><span class="line">    mov rax,0x02000001      ; syscall退出</span><br><span class="line">    xor rdi,rdi             ; 退出代码0</span><br><span class="line">    syscall                 ; 调用操作系统退出</span><br><span class="line">    ; call kernel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -fmacho64 hello.asm &amp;&amp; gcc hello.o &amp;&amp; ./a.out</span></span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>练习</strong>：确定两个程序之间的差异。</p>
</blockquote>
<h2 id="1-3-NASM-程序的结构"><a href="#1-3-NASM-程序的结构" class="headerlink" title="1.3. NASM 程序的结构"></a>1.3. NASM 程序的结构</h2><p>NASM 是基于行的。大多数程序由指令后跟一个或多个部分组成。行可以具有可选标签。大多数行都有一条指令,后跟零个或多个操作数。</p>
<p><img src="https://raw.githubusercontent.com/zhangjunlei26/NASM-Tutorial-CN/master/assets/nasmstructure.png" alt="nasmstructure.png"></p>
<p>通常,您将代码放在<code>.text</code>部分中,并将常量数据放在<code>.data</code>部分中。</p>
<h2 id="1-4-细节"><a href="#1-4-细节" class="headerlink" title="1.4. 细节"></a>1.4. 细节</h2><p>NASM 是一个很棒的汇编器,但是汇编语言很复杂。您不仅需要教程。您需要详细信息。很多细节。准备咨询：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.nasm.us/doc/">NASM 手册</a>,非常好！</li>
<li><a target="_blank" rel="noopener" href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">英特尔处理器手册</a></li>
</ul>
<h2 id="1-5-从掌握如下汇编指令开始"><a href="#1-5-从掌握如下汇编指令开始" class="headerlink" title="1.5. 从掌握如下汇编指令开始"></a>1.5. 从掌握如下汇编指令开始</h2><p>有数百条指令。您无法一次全部学习它们。从这些 start:</p>
<table>
<thead>
<tr>
<th><code>mov</code> <em>x</em>,<em>y</em></th>
<th><em>x</em> ← <em>y</em></th>
</tr>
</thead>
<tbody><tr>
<td><code>and</code> <em>x</em>,<em>y</em></td>
<td><em>x</em> ← <em>x</em> and <em>y</em></td>
</tr>
<tr>
<td><code>or</code> <em>x</em>,<em>y</em></td>
<td><em>x</em> ← <em>x</em> or <em>y</em></td>
</tr>
<tr>
<td><code>xor</code> <em>x</em>,<em>y</em></td>
<td><em>x</em> ← <em>x</em> xor <em>y</em></td>
</tr>
<tr>
<td><code>add</code> <em>x</em>,<em>y</em></td>
<td><em>x</em> ← <em>x</em> + <em>y</em></td>
</tr>
<tr>
<td><code>sub</code> <em>x</em>,<em>y</em></td>
<td><em>x</em> ← <em>x</em> – <em>y</em></td>
</tr>
<tr>
<td><code>inc</code> <em>x</em></td>
<td><em>x</em> ← <em>x</em> + 1</td>
</tr>
<tr>
<td><code>dec</code> <em>x</em></td>
<td><em>x</em> ← <em>x</em> – 1</td>
</tr>
<tr>
<td><code>syscall</code></td>
<td>调用操作系统例程</td>
</tr>
<tr>
<td><code>db</code></td>
<td>一个<a target="_blank" rel="noopener" href="http://www.nasm.us/xdoc/2.11.02/html/nasmdoc3.html#section-3.2">伪指令</a> 声明字节,这将是在内存中的程序运行时</td>
</tr>
</tbody></table>
<h2 id="1-6-三种操作数"><a href="#1-6-三种操作数" class="headerlink" title="1.6. 三种操作数"></a>1.6. 三种操作数</h2><h3 id="1-6-1-寄存器操作数"><a href="#1-6-1-寄存器操作数" class="headerlink" title="1.6.1. 寄存器操作数"></a>1.6.1. 寄存器操作数</h3><p>在本教程中,我们只关心整数寄存器和 xmm 寄存器。您应该已经知道什么是寄存器,但是这里是一个快速的回顾。16 个整数寄存器为 64 位宽,称为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15</span><br><span class="line">RAX RCX RDX RBX RSP RBP RSI RDI</span><br></pre></td></tr></table></figure>

<p>(请注意,其中的最后 8 个寄存器具有备用名称)您可以将每个寄存器的最低 32 位视为寄存器本身,但可以使用以下名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R0D R1D R2D R3D R4D R5D R6D R7D R8D R9D R10D R11D R12D R13D R14D R15D</span><br><span class="line">EAX ECX EDX EBX ESP EBP ESI EDI</span><br></pre></td></tr></table></figure>

<p>您可以使用以下名称将每个寄存器的最低 16 位看作一个寄存器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R0W R1W R2W R3W R4W R5W R6W R7W R8W R9W R10W R11W R12W R13W R14W R15W</span><br><span class="line">AX CX DX BX SP BP SI DI</span><br></pre></td></tr></table></figure>

<p>您可以使用以下名称将每个寄存器的最低 8 位看作一个寄存器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R0B R1B R2B R3B R4B R5B R6B R7B R8B R9B R10B R11B R12B R13B R14B R15B</span><br><span class="line">AL CL DL BL SPL BPL SIL DIL</span><br></pre></td></tr></table></figure>

<p>由于历史原因，<code>R0...R3</code>的第 15 至 8 位被命名为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AH CH DH BH</span><br></pre></td></tr></table></figure>

<p>最后,有 16 个 XMM 寄存器,每个 128 位宽,名为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XMM0 ... XMM15</span><br></pre></td></tr></table></figure>

<p>研究这张照片;希望它可以帮助：</p>
<p><img src="https://raw.githubusercontent.com/zhangjunlei26/NASM-Tutorial-CN/master/assets/rdx.png" alt="rdx.png"></p>
<h3 id="1-6-2-内存操作数"><a href="#1-6-2-内存操作数" class="headerlink" title="1.6.2. 内存操作数"></a>1.6.2. 内存操作数</h3><p>这些是寻址的基本形式：</p>
<ul>
<li><code>[ number ]</code></li>
<li><code>[ reg ]</code></li>
<li><code>[ reg + reg*scale ]</code> <em>小数位数只能是 1、2、4 或 8</em></li>
<li><code>[ reg + number ]</code></li>
<li><code>[ reg + reg*scale + number ]</code></li>
</ul>
<p>这个数字叫做<strong>位移</strong> ; 普通寄存器称为<strong>基</strong> ; 带有刻度的寄存器称为<strong>索引</strong>。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[750]               ; 仅位移</span><br><span class="line">[rbp]               ; 仅基址寄存器</span><br><span class="line">[rcx + rsi*4]       ; 基数+指数*比例</span><br><span class="line">[rbp + rdx]         ; scale is 1</span><br><span class="line">[rbx-8]             ; 位移-8</span><br><span class="line">[rax + rdi*8 + 500] ; 所有四个组成部分</span><br><span class="line">[rbx + counter]     ; 使用变量&quot;counter&quot;地址作为偏移</span><br></pre></td></tr></table></figure>

<h3 id="1-6-3-直接操作数"><a href="#1-6-3-直接操作数" class="headerlink" title="1.6.3. 直接操作数"></a>1.6.3. 直接操作数</h3><p>这些可以用多种方式编写。以下是官方文档中的一些示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">200         ; 十进制数</span><br><span class="line">0200        ; 仍然是十进制-前导0不会使其变为八进制</span><br><span class="line">0200d       ; 显式十进制-d后缀</span><br><span class="line">0d200       ; 也十进制-0d prefex</span><br><span class="line">0c8h        ; 十六进制-h后缀,但是前导0是必需的,因为c8h看起来像var</span><br><span class="line">0xc8        ; hex-经典的0x前缀</span><br><span class="line">0hc8        ; 十六进制-由于某些原因,NASM偏爱0h写法</span><br><span class="line">310q        ; 八进制-q后缀</span><br><span class="line">0q310       ; 八进制-0q前缀</span><br><span class="line">11001000b   ; 二进制-b后缀</span><br><span class="line">0b1100_1000 ; 二进制-0b前缀,顺便说一下,允许使用下划线</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-7-具有两个内存操作数的指令非常少见"><a href="#1-7-具有两个内存操作数的指令非常少见" class="headerlink" title="1.7. 具有两个内存操作数的指令非常少见"></a>1.7. 具有两个内存操作数的指令非常少见</h2><p>实际上,在本教程中我们将看不到任何此类说明。大多数基本说明只有以下几种形式：</p>
<table>
<thead>
<tr>
<th><code>add</code> <em>reg</em>, <em>reg</em></th>
</tr>
</thead>
<tbody><tr>
<td><code>add</code> <em>reg</em>,<em>mem</em></td>
</tr>
<tr>
<td><code>add</code> <em>reg</em>, <em>imm</em></td>
</tr>
<tr>
<td><code>add</code> <em>mem</em>,<em>reg</em></td>
</tr>
<tr>
<td><code>add</code> <em>mem</em>, <em>imm</em></td>
</tr>
</tbody></table>
<h2 id="1-8-定义数据并保留空间"><a href="#1-8-定义数据并保留空间" class="headerlink" title="1.8. 定义数据并保留空间"></a>1.8. 定义数据并保留空间</h2><p>这些示例来自 <a target="_blank" rel="noopener" href="https://cs.lmu.edu/~ray/notes/nasmtutorial/">docs 的第 3 章</a>。要将数据放入内存中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db 0x55               ; 只是字节0x55</span><br><span class="line">db 0x55,0x56,0x57     ; 连续三个字节</span><br><span class="line">db &#x27;a&#x27;,0x55           ; 字符常量可以</span><br><span class="line">db &#x27;hello&#x27;,13,10,&#x27;$&#x27;  ; 字符串常量也是如此</span><br><span class="line">dw 0x1234             ; 0x34 0x12</span><br><span class="line">dw &#x27;a&#x27;                ; 0x61 0x00(只是一个数字)</span><br><span class="line">dw &#x27;ab&#x27;               ; 0x61 0x62(字符常量)</span><br><span class="line">dw &#x27;abc&#x27;              ; 0x61 0x62 0x63 0x00(字符串)</span><br><span class="line">dd 0x12345678         ; 0x78 0x56 0x34 0x12</span><br><span class="line">dd 1.234567e20        ; 浮点常数</span><br><span class="line">dq 0x123456789abcdef0 ; 八字节常量</span><br><span class="line">dq 1.234567e20        ; 双精度浮点</span><br><span class="line">dt 1.234567e20        ; 扩展精度浮点</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还有其他形式。请稍候自行查阅 NASM 文档。</p>
<p>要保留空间(无需初始化),可以使用以下伪指令。它们应该放在一个称为<code>.bss</code>的小节中(如果您试图在一个<code>.text</code>小节中使用它们,将会出现错误)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer:         resb    64              ; 保留64个字节</span><br><span class="line">wordvar:        resw    1               ; 保留一个字</span><br><span class="line">realarray:      resq    10              ; 十个实数的数组</span><br></pre></td></tr></table></figure>

<h2 id="1-9-另一个例子"><a href="#1-9-另一个例子" class="headerlink" title="1.9. 另一个例子"></a>1.9. 另一个例子</h2><p>这是一个要研究的 macOS 程序：</p>
<p><code>triangle.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line">; 这是一个OSX控制台程序,将星号的小三角形写成标准</span><br><span class="line">; 输出。仅在macOS上运行。</span><br><span class="line">;</span><br><span class="line">; nasm -fmacho64 triangle.asm &amp;&amp; gcc hola.o &amp;&amp; ./a.out</span><br><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">          global    _main</span><br><span class="line">          default  rel</span><br><span class="line"></span><br><span class="line">          section   .text</span><br><span class="line">_main:</span><br><span class="line">          push      rbx                     ; OSX必须，保存栈，Linux下删除该行</span><br><span class="line">          mov       rdx, output             ; rdx holds address of next byte to write</span><br><span class="line">          mov       r8, 1                   ; initial line length</span><br><span class="line">          mov       r9, 0                   ; number of stars written on line so far</span><br><span class="line">line:</span><br><span class="line">          mov       byte [rdx], &#x27;*&#x27;         ; write single star</span><br><span class="line">          inc       rdx                     ; advance pointer to next cell to write</span><br><span class="line">          inc       r9                      ; &quot;count&quot; number so far on line</span><br><span class="line">          cmp       r9, r8                  ; did we reach the number of stars for this line?</span><br><span class="line">          jne       line                    ; not yet, keep writing on this line</span><br><span class="line">lineDone:</span><br><span class="line">          mov       byte [rdx], 10          ; write a new line char</span><br><span class="line">          inc       rdx                     ; and move pointer to where next char goes</span><br><span class="line">          inc       r8                      ; next line will be one char longer</span><br><span class="line">          mov       r9, 0                   ; reset count of stars written on this line</span><br><span class="line">          cmp       r8, maxlines            ; wait, did we already finish the last line?</span><br><span class="line">          jng       line                    ; if not, begin writing this line</span><br><span class="line">done:</span><br><span class="line">          mov       rax, 0x02000004         ; system call for write</span><br><span class="line">          mov       rdi, 1                  ; file handle 1 is stdout</span><br><span class="line">          mov       rsi, output             ; address of string to output</span><br><span class="line">          mov       rdx, dataSize           ; number of bytes</span><br><span class="line">          syscall                           ; invoke operating system to do the write</span><br><span class="line"></span><br><span class="line">          ;exit(0)</span><br><span class="line">          pop rbx                           ; OSX必须，弹出开头保存的栈，Linux下删除该行</span><br><span class="line">          ;mov       rax, 0x02000001         ; system call for exit</span><br><span class="line">          ;xor       rdi, rdi                ; exit code 0</span><br><span class="line">          ;syscall                           ; invoke operating system to exit</span><br><span class="line">          ret</span><br><span class="line"></span><br><span class="line">          section   .bss</span><br><span class="line">maxlines  equ       8</span><br><span class="line">dataSize  equ       44</span><br><span class="line">output:   resb      dataSize</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -fmacho64 triangle.asm &amp;&amp; ld triangle.o &amp;&amp; ./a.out</span></span><br><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br><span class="line">******</span><br><span class="line">*******</span><br><span class="line">********</span><br></pre></td></tr></table></figure>



<p>此示例中的新内容：</p>
<ul>
<li><code>cmp</code> 做比较</li>
<li><code>je</code>如果先前的比较相等则跳转。</li>
<li><code>jne</code>(如果不等于则跳转)</li>
<li><code>jl</code>(如果不等于则跳转)</li>
<li><code>jnl</code>(如果不小于则跳转)</li>
<li><code>jg</code>(如果大于则跳转)</li>
<li><code>jng</code>(如果不大于则跳转)</li>
<li><code>jle</code>(如果小于或等于则跳转)</li>
<li><code>jnle</code>(如果不小于或等于则跳转)</li>
<li><code>jge</code>(如果大于或等于则跳转)</li>
<li><code>jnge</code>(如果不大于或等于则跳转)</li>
<li><code>equ</code>实际上不是真正的指令。它只是定义了供汇编程序本身使用的缩写。(这是一个意义深远的想法)</li>
<li>本<code>.bss</code>节适用于<em>可写</em>数据。</li>
</ul>
<h2 id="1-10-使用-C-库"><a href="#1-10-使用-C-库" class="headerlink" title="1.10. 使用 C 库"></a>1.10. 使用 C 库</h2><p>仅使用 syscall 编写独立程序就已经很酷了，但很少见。我们想使用 C 库中的好东西。</p>
<p>为何在 C语言程序中，看上去都是从 <code>main</code>函数开始执行？这是因为 C  library的内部有<code>_start</code>标签！<code>_start</code>开始处的代码会做一些初始化的工作，然后调用<code>main</code>函数中的代码，最后执行清理工作，最终执行60号系统调用以退出。因此，您只需要实现<code>main</code>函数即可，我们可以在汇编语言中实现这么做：</p>
<p>如果您有 Linux,请尝试以下操作：</p>
<p>hola.asm</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line">; 使用C库将&quot; Hola,mundo&quot;写入控制台。程序运行在 Linux 或者其他在 C 语言库中不使用下划线的操作系统上。</span><br><span class="line">; 如何编译执行:</span><br><span class="line">; nasm -felf64 hola.asm &amp;&amp; gcc hola.o &amp;&amp; ./a.out</span><br><span class="line">; ----------------------------------------------------------------------------------------        </span><br><span class="line">global    main</span><br><span class="line">          extern    puts</span><br><span class="line"></span><br><span class="line">          section   .text</span><br><span class="line">main:                                       ; 这里被 C library初始化代码所调用</span><br><span class="line">          mov       rdi, message            ; rdi中的第一个整数(或指针)参数</span><br><span class="line">          call      puts                    ; puts(message)</span><br><span class="line">          ret                               ; 由 main 函数返回 C 语言库例程 </span><br><span class="line">message:</span><br><span class="line">          db        &quot;Hola, mundo&quot;, 0        ; 注意字符串必须在C中以0结尾</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -felf64 hola.asm &amp;&amp; gcc hola.o &amp;&amp; ./a.out</span></span><br><span class="line">Hola, mundo</span><br></pre></td></tr></table></figure>



<p>在 macOS 下,看起来会有些不同：</p>
<p>hola.asm</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line">; 这是一个macOS控制台程序,它在一行上写入&quot; Hola,mundo&quot;,然后退出。</span><br><span class="line">; 它使用C库中的puts。编译汇编代码并运行：</span><br><span class="line">;</span><br><span class="line">; nasm -fmacho64 hola.asm &amp;&amp; gcc hola.o &amp;&amp; ./a.out</span><br><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line">          global    _main</span><br><span class="line">          extern    _puts</span><br><span class="line"></span><br><span class="line">          section   .text</span><br><span class="line">_main:    push      rbx                     ; 调用堆栈必须对齐</span><br><span class="line">          lea       rdi, [rel message]      ; 第一个参数是消息的地址</span><br><span class="line">          call      _puts                   ; puts(message)</span><br><span class="line">          pop       rbx                     ; Fix up stack before returning</span><br><span class="line">          ret</span><br><span class="line"></span><br><span class="line">          section   .data</span><br><span class="line">message:  db        &quot;Hola, mundo&quot;, 0        ; C字符串末尾需要一个零字节结尾</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -fmacho64 hola.asm &amp;&amp; gcc hola.o &amp;&amp; ./a.out</span></span><br><span class="line">Hola, mundo</span><br></pre></td></tr></table></figure>



<p>在 macOS 领域中,C 函数(或实际上是从一个模块导出到另一个模块的任何函数)必须以下划线作为前缀。调用堆栈必须在 16 字节边界上对齐(稍后会对此进行更多介绍)。并且在访问命名变量时,需要<code>rel</code>前缀。</p>
<h2 id="1-11-理解参数调用约束"><a href="#1-11-理解参数调用约束" class="headerlink" title="1.11. 理解参数调用约束"></a>1.11. 理解参数调用约束</h2><p>我们怎么知道<code>puts</code>的参数放在<code>RDI</code>中？答：有多个参数调用约定。</p>
<p>当你为 C library集成的 64 位 Linux 编写代码时，必须遵循<a href="%5Bhere%5D(https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-1.0.pdf)">《AMD64 ABI Reference》</a>中说明的调用约定 。您也可以从<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_Calling_Conventions">Wikipedia</a>获这些信息 。</p>
<blockquote>
<p>注：<code> x86-64 System V ABI</code>下载地址曾是<code>http://x86-64.org/documentation/abi.pdf</code>，现在 System V x86-64 psABI 已迁移到GitHub上维护，最新版本可以查看 <a target="_blank" rel="noopener" href="https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI">J.J. Lu的Github Wiki</a>。</p>
</blockquote>
<p>在这里列出最重要的几点：</p>
<ul>
<li>传递参数时，按照从左到右的顺序，将尽可能多的参数依次保存在寄存器中。存放位置的寄存器顺序是确定的：<ul>
<li>对于整数和指针：<code>rdi</code>,<code>rsi</code>,<code>rdx</code>,<code>rcx</code>,<code>r8</code>,<code>r9</code>。</li>
<li>对于浮点(float和double类型)：<code>xmm0</code>,<code>xmm1</code>,<code>xmm2</code>,<code>xmm3</code>,<code>xmm4</code>,<code>xmm5</code>, <code> xmm6</code>,<code>xmm7</code></li>
</ul>
</li>
<li>剩下的参数将按照从右到左的顺序压入栈中，并在调用之后 <em>由调用函数推出栈</em> 。</li>
<li>等所有的参数传入后，会生成调用指令。所以当被调用函数得到控制权后，返回地址会被保存在 <code>[rsp]</code> 中，第一个局部变量会被保存在 <code>[rsp+8]</code> 中，以此类推。</li>
<li><strong>栈指针<code>rsp</code>在调用之前，必须与16 字节边界对齐处理</strong>。当然，调用的过程中只会把一个 8 bytes 的返回地址推入栈中，所以当函数得到控制权时，<code>rsp</code> 并没有对齐。你需要向栈中压入数据或者从 <code>rsp</code> 减去 8 来使之对齐。</li>
<li>调用函数需要预留如下寄存器(the calle-save registers)：<code>rbp</code>,<code>rbx</code>,<code>r12</code>,<code>r13</code>,<code>r14</code>,<code>r15</code>。其他的寄存器可以自由使用。</li>
<li>被调用函数也需要保存 XMCSR 的控制位和 x87 指令集的控制字，但是 x87 指令在 64 位系统中很少见，所以您不必担心这一点。</li>
<li>整数被返回在<code>rax</code>或<code>rdx:rax</code>,浮点值返回在<code>xmm0</code>或<code>xmm1:xmm0</code>。</li>
</ul>
<p>以上罗列的都理解了吗？什么，还没有？没关系，接下来我们再来一些示例，练习一下。</p>
<p>如下代码，展示如何保存和恢复寄存器：</p>
<p><code>fib.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">; ----------------------------------------------------------------------------</span><br><span class="line">; 一个写入前90个斐波那契数字的64位Linux应用程序。至</span><br><span class="line">; 编译汇编代码并运行：</span><br><span class="line">;</span><br><span class="line">; nasm -felf64 fib.asm &amp;&amp; gcc fib.o &amp;&amp; ./a.out</span><br><span class="line">; ----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">        global  main</span><br><span class="line">        extern  printf</span><br><span class="line"></span><br><span class="line">        section .text</span><br><span class="line">main:</span><br><span class="line">        push rbx                               ; 我们必须保存它,因为我们使用它</span><br><span class="line"></span><br><span class="line">        mov ecx,90                             ; ecx将倒数至0</span><br><span class="line">        xor rax,rax                            ; rax将保留当前数字</span><br><span class="line">        xor rbx,rbx                            ; rbx将保留下一个数字</span><br><span class="line">        inc rbx                                ; rbx最初是1</span><br><span class="line">print:</span><br><span class="line">        ; 我们需要调用printf,但是我们使用的是rax,rbx和rcx。打印</span><br><span class="line">        ; 可能会破坏rax和rcx,因此我们将在调用之前保存它们,并且</span><br><span class="line">        ; 之后恢复它们。</span><br><span class="line"></span><br><span class="line">        push rax                               ; caller-save register</span><br><span class="line">        push rcx                               ; caller-save register</span><br><span class="line"></span><br><span class="line">        mov rdi,printf                         ; 设置第一个参数(format)</span><br><span class="line">        mov rsi,rax                            ; 设置第二个参数(current_number)</span><br><span class="line">        xor rax,rax                            ; 因为printf是varargs</span><br><span class="line"></span><br><span class="line">                                               ; 堆栈已经对齐,因为我们压入了三个8字节寄存器</span><br><span class="line">        call printf                            ; printf(format, current_number)</span><br><span class="line"></span><br><span class="line">        pop rcx                                ; restore caller-save register</span><br><span class="line">        pop rax                                ; restore caller-save register</span><br><span class="line"></span><br><span class="line">        mov rdx,rax                            ; save the current number</span><br><span class="line">        mov rax,rbx                            ; next number is now current</span><br><span class="line">        add rbx,rdx                            ; get the new next number</span><br><span class="line">        dec ecx                                ; count down</span><br><span class="line">        jnz print                              ; if not done counting, do some more</span><br><span class="line"></span><br><span class="line">        pop rbx                                ; returing之前还原rbx</span><br><span class="line">        ret</span><br><span class="line">format:</span><br><span class="line">        db  &quot;％20ld&quot;,10,0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -felf64 fib.asm &amp;&amp; gcc fib.o &amp;&amp; ./a.out</span></span><br><span class="line">                   0</span><br><span class="line">                   1</span><br><span class="line">                   1</span><br><span class="line">                   2</span><br><span class="line">                   .</span><br><span class="line">                   .</span><br><span class="line">                   .</span><br><span class="line">  679891637638612258</span><br><span class="line"> 1100087778366101931</span><br><span class="line"> 1779979416004714189</span><br></pre></td></tr></table></figure>



<p>通过如上代码，我们学习如下指令：</p>
<table>
<thead>
<tr>
<th><code>push</code> <em>x</em></th>
<th>减少<code>rsp</code>操作数的大小,然后将<em>x</em>存储在<code>[rsp]</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>pop</code> <em>x</em></td>
<td>移动<code>[rsp]</code>到<em>X</em>,然后增加<code>rsp</code>由操作数的大小</td>
</tr>
<tr>
<td><code>jnz</code> <em>label</em></td>
<td>如果设置了处理器的 Z(零)标志,请跳至给定标签</td>
</tr>
<tr>
<td><code>call</code> <em>label</em></td>
<td>按下下一条指令的地址,然后跳到标签</td>
</tr>
<tr>
<td><code>ret</code></td>
<td>弹出指令指针</td>
</tr>
</tbody></table>
<h2 id="1-12-C-和汇编语言混合调用示例"><a href="#1-12-C-和汇编语言混合调用示例" class="headerlink" title="1.12. C 和汇编语言混合调用示例"></a>1.12. C 和汇编语言混合调用示例</h2><p>该程序只是一个简单的函数,它接受三个整数参数并返回最大值。</p>
<p><code>maxofthree.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line">; 一个64位函数,该函数返回其三个64位整数的最大值</span><br><span class="line">; 论点。该函数具有签名：</span><br><span class="line">;</span><br><span class="line">; int64_t maxofthree(int64_t x,int64_t y,int64_t z)</span><br><span class="line">;</span><br><span class="line">; 请注意,参数已经在rdi,rsi和rdx中传递。我们</span><br><span class="line">; 只需返回rax中的值即可。</span><br><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line"></span><br><span class="line">        global  maxofthree</span><br><span class="line">        section .text</span><br><span class="line">maxofthree：</span><br><span class="line">        mov rax,rdi    ; 结果(rax)最初持有x</span><br><span class="line">        cmp rax,rsi    ; x小于y吗？</span><br><span class="line">        cmovl rax,rsi  ; 如果是这样,将结果设置为y</span><br><span class="line">        cmp rax,rdx    ; max(x,y)小于z吗？</span><br><span class="line">        cmovl rax,rdx  ; 如果是这样,将结果设置为z</span><br><span class="line">        ret            ; 最大值将为rax</span><br></pre></td></tr></table></figure>

<p>这是一个调用汇编语言函数的 C 程序。</p>
<p><code>callmaxofthree.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一个小程序,说明如何调用我们用汇编语言编写的maxofthree函数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">maxofthree</span> <span class="params">(<span class="keyword">int64_t</span>,<span class="keyword">int64_t</span>,<span class="keyword">int64_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, maxofthree(<span class="number">1</span>, <span class="number">-4</span>, <span class="number">-7</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, maxofthree(<span class="number">2</span>, <span class="number">-6</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, maxofthree(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, maxofthree(<span class="number">-2</span>, <span class="number">4</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, maxofthree(<span class="number">2</span>, <span class="number">-6</span>, <span class="number">5</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, maxofthree(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -felf64 maxofthree.asm &amp;&amp; gcc callmaxofthree.c maxofthree.o &amp;&amp; ./a.out</span></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure>



<h2 id="1-13-有条件的指令"><a href="#1-13-有条件的指令" class="headerlink" title="1.13. 有条件的指令"></a>1.13. 有条件的指令</h2><p>在算术或逻辑指令或比较指令之后<code>cmp</code>,处理器会设置或清除其中的位<code>rflags</code>。最有趣的标志是：</p>
<ul>
<li><code>s</code> (标志)</li>
<li><code>z</code> (零)</li>
<li><code>c</code> (携带)</li>
<li><code>o</code> (溢出)</li>
</ul>
<p>因此,执行完一条加法指令后,我们可以根据新的标志设置执行跳转,移动或设置。例如：</p>
<table>
<thead>
<tr>
<th><code>jz</code> <em>标签</em></th>
<th>如果运算结果为零,则跳至标签 L</th>
</tr>
</thead>
<tbody><tr>
<td><code>cmovno</code> <em>x</em>,<em>y</em></td>
<td><em>x ← y</em> 如果最后的操作确实<em>不</em>溢出</td>
</tr>
<tr>
<td><code>setc</code> <em>x</em></td>
<td>如果最后一个操作带有进位,则<em>x</em> ← <em>1</em>,否则,<em>x</em> ← *0,*否则(<em>x</em>必须是字节大小的寄存器或存储器位置)</td>
</tr>
</tbody></table>
<p>条件指令具有三种基本形式：<code>j</code>用于条件跳转,<code>cmov</code>用于条件移动和<code>set</code>用于条件设置。指令的后缀具有 30 种形式之一： <code>s ns z nz c nc o no p np pe po e ne l nl le nle g ng ge nge a na ae nae b nb be nbe</code>。</p>
<h2 id="1-14-命令行参数"><a href="#1-14-命令行参数" class="headerlink" title="1.14. 命令行参数"></a>1.14. 命令行参数</h2><p>在 C 中，<code>main</code> 是一个古老而简单的函数，其实它自身可以附带一些参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></span><br></pre></td></tr></table></figure>

<p>因此,您猜到了，<code>argc</code>以<code>rdi</code>结尾，而 <code>argv</code>(指针)以<code>rsi</code>结尾。下面运用这一点，实现将命令行参数简单地逐行显示的程序：</p>
<p><code>echo.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line">; 一个显示其命令行参数(每行一个)的64位程序。</span><br><span class="line">;</span><br><span class="line">; 在输入时,rdi将包含argc,而rsi将包含argv。</span><br><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line"></span><br><span class="line">        global  main</span><br><span class="line">        extern  puts</span><br><span class="line">        section .text</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">        push rdi      ; 保存 puts 函数需要用到的寄存器 </span><br><span class="line">        push rsi</span><br><span class="line">        sub rsp,8     ; 调用函数前让栈顶对齐 </span><br><span class="line"></span><br><span class="line">        mov rdi,[rsi] ; 需要输出的字符串参数 </span><br><span class="line">        call puts     ; 调用 puts 输出</span><br><span class="line"></span><br><span class="line">        add rsp,8     ; 恢复％rsp到未对齐的值</span><br><span class="line">        pop rsi       ; 恢复puts用到的寄存器</span><br><span class="line">        pop rdi</span><br><span class="line"></span><br><span class="line">        add rsi,8     ; 指向下一个参数</span><br><span class="line">        dec rdi       ; 递减参数计数</span><br><span class="line">        jnz main      ; 如果未读完参数则继续 </span><br><span class="line"></span><br><span class="line">        ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -felf64 echo.asm &amp;&amp; gcc echo.o &amp;&amp; ./a.out dog 22 -zzz <span class="string">&quot;hi there&quot;</span></span></span><br><span class="line">./a.out</span><br><span class="line">dog</span><br><span class="line">22</span><br><span class="line">-zzz</span><br><span class="line">hi there</span><br></pre></td></tr></table></figure>



<h2 id="1-15-一个更长一些的例子"><a href="#1-15-一个更长一些的例子" class="headerlink" title="1.15. 一个更长一些的例子"></a>1.15. 一个更长一些的例子</h2><p>请注意,就 C library而言, 命令行参数总是以字符串的形式传入的。如果要将参数视为整数使用，请调用<code>atoi</code>函数。下面是一个计算 $x^y$ 的函数。</p>
<p><code>power.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line">; 一个用于计算x ^ y的64位命令行应用程序。</span><br><span class="line">;</span><br><span class="line">; 语法：power x y</span><br><span class="line">; x和y均是(32位)整数</span><br><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line"></span><br><span class="line">        global  main</span><br><span class="line">        extern  printf</span><br><span class="line">        extern  puts</span><br><span class="line">        extern  atoi</span><br><span class="line"></span><br><span class="line">        section .text</span><br><span class="line">main:</span><br><span class="line">        push    r12                     ; 调用者保存寄存器 </span><br><span class="line">        push    r13</span><br><span class="line">        push    r14</span><br><span class="line">        ; 通过压入三个寄存器的值, 栈已经对齐 </span><br><span class="line"></span><br><span class="line">        cmp     rdi, 3                  ; 必须有且仅有 2 个参数</span><br><span class="line">        jne     error1</span><br><span class="line"></span><br><span class="line">        mov     r12, rsi                ; argv</span><br><span class="line"></span><br><span class="line">        ; 我们将使用 ecx 作为指数的计数器, 直至 ecx 减到 0。</span><br><span class="line">        ; 使用 esi 来保存基数, 使用 eax 保存乘积。</span><br><span class="line"></span><br><span class="line">        mov     rdi, [r12+16]           ; argv[2]</span><br><span class="line">        call    atoi                    ; y in eax</span><br><span class="line">        cmp     eax, 0                  ; 不允许负指数 </span><br><span class="line">        jl      error2</span><br><span class="line">        mov     r13d, eax               ; y in r13d</span><br><span class="line"></span><br><span class="line">        mov     rdi, [r12+8]            ; argv</span><br><span class="line">        call    atoi                    ; x in eax</span><br><span class="line">        mov     r14d, eax               ; x in r14d</span><br><span class="line"></span><br><span class="line">        mov     eax, 1                  ; 初始结果 start with answer = 1</span><br><span class="line">check:</span><br><span class="line">        test    r13d, r13d              ; 递减 y 直至 0</span><br><span class="line">        jz      gotit                   ; done</span><br><span class="line">        imul    eax, r14d               ; 再乘上一个 x</span><br><span class="line">        dec     r13d</span><br><span class="line">        jmp     check</span><br><span class="line">gotit:                                  ; print report on success</span><br><span class="line">        mov     rdi, answer</span><br><span class="line">        movsxd  rsi, eax</span><br><span class="line">        xor     rax, rax</span><br><span class="line">        call    printf</span><br><span class="line">        jmp     done</span><br><span class="line">error1:                                 ; print error message</span><br><span class="line">        mov     edi, badArgumentCount</span><br><span class="line">        call    puts</span><br><span class="line">        jmp     done</span><br><span class="line">error2:                                 ; print error message</span><br><span class="line">        mov     edi, negativeExponent</span><br><span class="line">        call    puts</span><br><span class="line">done:                                   ; restore saved registers</span><br><span class="line">        pop     r14</span><br><span class="line">        pop     r13</span><br><span class="line">        pop     r12</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">answer:</span><br><span class="line">        db      &quot;%d&quot;, 10, 0</span><br><span class="line">badArgumentCount:</span><br><span class="line">        db      &quot;Requires exactly two arguments&quot;, 10, 0</span><br><span class="line">negativeExponent:</span><br><span class="line">        db      &quot;The exponent may not be negative&quot;, 10, 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -felf64 power.asm &amp;&amp; gcc -o power power.o</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./power 2 19</span></span><br><span class="line">524288</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./power 3 -8</span></span><br><span class="line">The exponent may not be negative</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./power 1 500</span></span><br><span class="line">1</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./power 1</span></span><br><span class="line">Requires exactly two arguments</span><br></pre></td></tr></table></figure>



<h2 id="1-16-浮点数指令"><a href="#1-16-浮点数指令" class="headerlink" title="1.16. 浮点数指令"></a>1.16. 浮点数指令</h2><p>浮点数参数保存在 xmm 寄存器中。下面是一个用来计算存放在数组中的浮点数的和的简单的函数：</p>
<p><code>sum.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line">; 一个64位程序,该函数返回浮点数数组元素之和</span><br><span class="line">; 函数声明如下：</span><br><span class="line">;</span><br><span class="line">; double sum(double []array,uint64_t length)</span><br><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line"></span><br><span class="line">        global  sum</span><br><span class="line">        section .text</span><br><span class="line">sum:</span><br><span class="line">        xorpd   xmm0, xmm0              ; 初始化累加和为 0</span><br><span class="line">        cmp     rsi, 0                  ; 考虑数组长度为 0 的特殊情形 </span><br><span class="line">        je      done</span><br><span class="line">next:</span><br><span class="line">        addsd   xmm0, [rdi]             ; 累加当前数组元素的值 </span><br><span class="line">        add     rdi, 8                  ; 指向下一个数组元素</span><br><span class="line">        dec     rsi                     ; 计数器递减</span><br><span class="line">        jnz     next                    ; 如果计数器未归0，则继续累加 </span><br><span class="line">done:</span><br><span class="line">        ret                             ; 返回保存在 xmm0 寄存器中的值 </span><br></pre></td></tr></table></figure>

<p>请注意,浮点指令具有<code>sd</code>后缀;这是最常见的一种,但稍后我们会再看到其他一些。这是一个调用它的 C 程序：</p>
<p><code>callum.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明如何调用用汇编语言编写的sum函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span>[], <span class="keyword">uint64_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> test[] = &#123;</span><br><span class="line">        <span class="number">40.5</span>, <span class="number">26.7</span>, <span class="number">21.9</span>, <span class="number">1.5</span>, <span class="number">-40.5</span>, <span class="number">-23.4</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%20.7f\n&quot;</span>, sum(test, <span class="number">6</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%20.7f\n&quot;</span>, sum(test, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%20.7f\n&quot;</span>, sum(test, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%20.7f\n&quot;</span>, sum(test, <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -felf64 sum.asm &amp;&amp; gcc sum.o callsum.c &amp;&amp; ./a.out</span></span><br><span class="line">          26.7000000</span><br><span class="line">          67.2000000</span><br><span class="line">           0.0000000</span><br><span class="line">          89.1000000</span><br></pre></td></tr></table></figure>



<h2 id="1-17-数据段"><a href="#1-17-数据段" class="headerlink" title="1.17. 数据段"></a>1.17. 数据段</h2><p>在大多数操作系统上,.data 数据段是只读的,所以你需要使用数据段。.data 部分仅仅用来初始化数据，而您还可以发现有一个特殊的.bss 的段，是用来存放未初始化过的数据的下面是一个程序用来计算通过命令行参数传递的整数的平均值，并且以浮点数输出结果的程序。</p>
<p><code>average.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line">; 一个把参数当做整数处理, 并且以浮点数形式输出他们平均值的 64 位程序。</span><br><span class="line">; 这个程序将使用一个数据段来保存中间结果。</span><br><span class="line">; 这不是必须的, 但是在此我们想展示数据段是如何使用的。</span><br><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line"></span><br><span class="line">        global   main</span><br><span class="line">        extern   atoi</span><br><span class="line">        extern   printf</span><br><span class="line">        default  rel</span><br><span class="line"></span><br><span class="line">        section  .text</span><br><span class="line">main:</span><br><span class="line">        dec      rdi              ; argc-1,因为我们不计算程序名称</span><br><span class="line">        jz       nothingToAverage</span><br><span class="line">        mov      [count], rdi     ; 保存浮点数参数的个数 </span><br><span class="line">accumulate:</span><br><span class="line">        push     rdi              ; 保存调用 atoi 需要使用的寄存器 </span><br><span class="line">        push     rsi</span><br><span class="line">        mov      rdi, [rsi+rdi*8] ; argv[rdi]</span><br><span class="line">        call     atoi             ; 现在 rax 里保存着 arg 的整数值 </span><br><span class="line">        pop      rsi              ; 调用完 atoi 函数后恢复寄存器 </span><br><span class="line">        pop      rdi</span><br><span class="line">        add      [sum], rax       ; 继续累加 </span><br><span class="line">        dec      rdi              ; 递减 </span><br><span class="line">        jnz      accumulate       ; 还有参数吗?</span><br><span class="line">average:</span><br><span class="line">        cvtsi2sd xmm0, [sum]</span><br><span class="line">        cvtsi2sd xmm1, [count]</span><br><span class="line">        divsd    xmm0, xmm1       ; xmm0 现在值为 sum/count</span><br><span class="line">        mov      rdi, format      ; printf 的第一个参数 [注: 输出格式]</span><br><span class="line">        mov      rax, 1           ; printf 是多参数的, 含有一个不是整数的参数 </span><br><span class="line"></span><br><span class="line">        sub      rsp, 8           ; 对齐栈指针 </span><br><span class="line">        call     printf           ; printf(format, sum/count)</span><br><span class="line">        add      rsp, 8           ; 恢复栈指针 </span><br><span class="line"></span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">nothingToAverage:</span><br><span class="line">        mov      rdi, error</span><br><span class="line">        xor      rax, rax</span><br><span class="line">        call     printf</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">        section  .data</span><br><span class="line">count:  dq       0</span><br><span class="line">sum:    dq       0</span><br><span class="line">format: db       &quot;%g&quot;, 10, 0</span><br><span class="line">error:  db       &quot;There are no command line arguments to average&quot;, 10, 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -felf64 average.asm &amp;&amp; gcc average.o &amp;&amp; ./a.out 19 8 21 -33</span></span><br><span class="line">3.75</span><br><span class="line"><span class="meta">$</span><span class="bash"> nasm -felf64 average.asm &amp;&amp; gcc average.o &amp;&amp; ./a.out</span></span><br><span class="line">There are no command line arguments to average</span><br></pre></td></tr></table></figure>



<p>该程序着重介绍了一些在整数和浮点值之间转换的处理器指令。一些最常见的是：</p>
<table>
<thead>
<tr>
<th><code>cvtsi2sd</code> <em>xmmreg,r/m32</em></th>
<th><em>xmmreg [63..0]</em> ← <em>intToDouble(r / m32)</em></th>
</tr>
</thead>
<tbody><tr>
<td><code>cvtsi2ss</code> <em>xmmreg,r/m32</em></td>
<td><em>xmmreg [31..0]</em> ← <em>intToFloat(r / m32)</em></td>
</tr>
<tr>
<td><code>cvtsd2si</code> <em>reg32</em>,<em>xmmr/m64</em></td>
<td><em>reg32</em> ← <em>doubleToInt(xmmr / m64)</em></td>
</tr>
<tr>
<td><code>cvtss2si</code> <em>reg32</em>,<em>xmmr/m32</em></td>
<td><em>reg32</em> ← <em>floatToInt(xmmr / m32)</em></td>
</tr>
</tbody></table>
<h2 id="1-18-递归"><a href="#1-18-递归" class="headerlink" title="1.18. 递归"></a>1.18. 递归</h2><p>也许令人惊讶的是,实现递归功能并没有什么不同寻常的。您只需要像往常一样小心保存寄存器的状态即可。在递归调用周围推动和弹出是一种典型的策略。</p>
<p><code>factorial.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">; ----------------------------------------------------------------------------</span><br><span class="line">; 一种递归函数的实现：</span><br><span class="line">;</span><br><span class="line">;   uint64_t factorial(uint64_t n) &#123;</span><br><span class="line">;       return (n &lt;= 1) ? 1 : n * factorial(n-1);</span><br><span class="line">;   &#125;</span><br><span class="line">; ----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">        global  factorial</span><br><span class="line"></span><br><span class="line">        section .text</span><br><span class="line">factorial:</span><br><span class="line">        cmp     rdi, 1                  ; n &lt;= 1?</span><br><span class="line">        jnbe    L1                      ; 如果不是, 进行递归调用 </span><br><span class="line">        mov     rax, 1                  ; 否则, 返回 1</span><br><span class="line">        ret</span><br><span class="line">L1:</span><br><span class="line">        push    rdi                     ; 将n保存在堆栈上 (同时对齐 %rsp!)</span><br><span class="line">        dec     rdi                     ; n-1</span><br><span class="line">        call    factorial               ; factorial(n-1), 返回值保保存到 %rax</span><br><span class="line">        pop     rdi                     ; 恢复 n</span><br><span class="line">        imul    rax, rdi                ; n * factorial(n-1), 保存到 %rax</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>一个调用示例：</p>
<p><code>callfactorial.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *这是一个调用外部定义的阶乘函数的程序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">factorial</span><span class="params">(<span class="keyword">uint64_t</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint64_t</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;factorial(%2lu) = %lu\n&quot;</span>, i, factorial(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -felf64 factorial.asm &amp;&amp; gcc -std=c99 factorial.o callfactorial.c &amp;&amp; ./a.out</span></span><br><span class="line">factorial( 0) = 1</span><br><span class="line">factorial( 1) = 1</span><br><span class="line">factorial( 2) = 2</span><br><span class="line">factorial( 3) = 6</span><br><span class="line">factorial( 4) = 24</span><br><span class="line">factorial( 5) = 120</span><br><span class="line">factorial( 6) = 720</span><br><span class="line">factorial( 7) = 5040</span><br><span class="line">factorial( 8) = 40320</span><br><span class="line">factorial( 9) = 362880</span><br><span class="line">factorial(10) = 3628800</span><br><span class="line">factorial(11) = 39916800</span><br><span class="line">factorial(12) = 479001600</span><br><span class="line">factorial(13) = 6227020800</span><br><span class="line">factorial(14) = 87178291200</span><br><span class="line">factorial(15) = 1307674368000</span><br><span class="line">factorial(16) = 20922789888000</span><br><span class="line">factorial(17) = 355687428096000</span><br><span class="line">factorial(18) = 6402373705728000</span><br><span class="line">factorial(19) = 121645100408832000</span><br></pre></td></tr></table></figure>



<h2 id="1-19-SIMD-并行"><a href="#1-19-SIMD-并行" class="headerlink" title="1.19. SIMD 并行"></a>1.19. SIMD 并行</h2><p>XMM 寄存器可以对浮点值进行一次算术运算(一次标量)或一次执行多次运算(打包)。操作具有以下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op xmmreg_or_memory,xmmreg</span><br></pre></td></tr></table></figure>

<p>对于浮点加法,说明如下：</p>
<table>
<thead>
<tr>
<th><code>addpd</code></th>
<th>并行执行 2 个双精度加法（添加压缩双精度）</th>
</tr>
</thead>
<tbody><tr>
<td><code>addsd</code></td>
<td>使用寄存器的低 64 位仅执行一次双精度加法（将标量加倍）</td>
</tr>
<tr>
<td><code>addps</code></td>
<td>并行执行 4 个单精度加法（添加打包的单个）</td>
</tr>
<tr>
<td><code>addss</code></td>
<td>使用寄存器的低 32 位仅执行一个单精度加法（加标量单）</td>
</tr>
</tbody></table>
<p>这是一个可以一次添加四个浮点数的函数：</p>
<p><code>add_four_floats.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">; void add_four_floats(float x[4], float y[4])</span><br><span class="line">; x[i] += y[i] for i in range(0..4)</span><br><span class="line"></span><br><span class="line">        global   add_four_floats</span><br><span class="line">        section  .text</span><br><span class="line"></span><br><span class="line">add_four_floats:</span><br><span class="line">        movdqa   xmm0, [rdi]            ; x的所有四个值</span><br><span class="line">        movdqa   xmm1, [rsi]            ; y的所有四个值</span><br><span class="line">        addps    xmm0, xmm1             ; 一次完成所有四个总和</span><br><span class="line">        movdqa   [rdi], xmm0</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>一个呼叫者：</p>
<p><code>test_add_four_floats.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_four_floats</span><span class="params">(<span class="keyword">float</span>[], <span class="keyword">float</span>[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> x[] = &#123;<span class="number">-29.750</span>, <span class="number">244.333</span>, <span class="number">887.29</span>, <span class="number">48.1E22</span>&#125;;</span><br><span class="line">    <span class="keyword">float</span> y[] = &#123;<span class="number">29.750</span>,  <span class="number">199.333</span>, <span class="number">-8.29</span>,  <span class="number">22.1E23</span>&#125;;</span><br><span class="line">    add_four_floats(x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n%f\n%f\n%f\n&quot;</span>, x[<span class="number">0</span>], x[<span class="number">1</span>], x[<span class="number">2</span>], x[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以参考：<a target="_blank" rel="noopener" href="http://rayseyfarth.com/asm/pdf/ch11-floating-point.pdf">nice little x86 floating-point slide deck from Ray Seyfarth</a></p>
<h2 id="1-20-饱和运算"><a href="#1-20-饱和运算" class="headerlink" title="1.20. 饱和运算"></a>1.20. 饱和运算</h2><p>XMM 寄存器还可以对整数进行算术运算。这些说明具有以下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op xmmreg_or_memory, xmmreg</span><br></pre></td></tr></table></figure>

<p>对于整数加法,说明如下：</p>
<table>
<thead>
<tr>
<th><code>paddb</code></th>
<th>做 16 个字节加法</th>
</tr>
</thead>
<tbody><tr>
<td><code>paddw</code></td>
<td>做 8 个单词加法</td>
</tr>
<tr>
<td><code>paddd</code></td>
<td>做 4 个 dword 加法</td>
</tr>
<tr>
<td><code>paddq</code></td>
<td>做 2 个 qword 加法</td>
</tr>
<tr>
<td><code>paddsb</code></td>
<td>执行 16 个字节加法并带符号饱和度（80..7F）</td>
</tr>
<tr>
<td><code>paddsw</code></td>
<td>进行 8 个带符号饱和的单词加法（8000..7F）</td>
</tr>
<tr>
<td><code>paddusb</code></td>
<td>执行 16 个字节的无符号饱和（00..FF）</td>
</tr>
<tr>
<td><code>paddusw</code></td>
<td>进行 8 个无符号饱和（00..FFFF）的单词加法</td>
</tr>
</tbody></table>
<p>这是一个例子。它还说明了如何加载 XMM 寄存器。您无法加载立即值;您必须使用它<code>movaps</code>来移出内存。还有其他方法,但是我们不会在本教程中介绍所有内容。</p>
<p><code>satexample.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line">; 有符号饱和运算示例。</span><br><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line">        global  main</span><br><span class="line">        extern  printf</span><br><span class="line"></span><br><span class="line">        section .text</span><br><span class="line">main:</span><br><span class="line">        push    rbp</span><br><span class="line">        movaps  xmm0, [arg1]</span><br><span class="line">        movaps  xmm1, [arg2]</span><br><span class="line">        paddsw  xmm0, xmm1</span><br><span class="line">        movaps  [result], xmm0</span><br><span class="line"></span><br><span class="line">        lea     rdi, [format]</span><br><span class="line">        mov     esi, dword [result]</span><br><span class="line">        mov     edx, dword [result+4]</span><br><span class="line">        mov     ecx, dword [result+8]</span><br><span class="line">        mov     r8d, dword [result+12]</span><br><span class="line">        xor     rax, rax</span><br><span class="line">        call    printf</span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br><span class="line">        section .data</span><br><span class="line">        align   16</span><br><span class="line">arg1:   dw      0x3544,0x24FF,0x7654,0x9A77,0xF677,0x9000,0xFFFF,0x0000</span><br><span class="line">arg2:   dw      0x7000,0x1000,0xC000,0x1000,0xB000,0xA000,0x1000,0x0000</span><br><span class="line">result: dd      0, 0, 0, 0</span><br><span class="line">format: db      &#x27;%x%x%x%x&#x27;,10,0</span><br></pre></td></tr></table></figure>



<h2 id="1-21-图形"><a href="#1-21-图形" class="headerlink" title="1.21. 图形"></a>1.21. 图形</h2><p>TODO</p>
<h2 id="1-22-局部变量和堆栈框架"><a href="#1-22-局部变量和堆栈框架" class="headerlink" title="1.22. 局部变量和堆栈框架"></a>1.22. 局部变量和堆栈框架</h2><p>首先,请阅读<a target="_blank" rel="noopener" href="http://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64/">Eli Bendersky 的文章,</a> 该概述比我的简短笔记更完整。</p>
<p>调用函数时,调用者将首先将参数存入正确的寄存器中，然后发出<code>call</code>指令。调用之前,超出寄存器覆盖范围的其他参数将被推入栈中。所调用的指令会把返回地址存入栈顶。所以如果有以下的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int64_t example(int64_t x, int64_t y) &#123;</span><br><span class="line">    int64_t a, b, c;</span><br><span class="line">    b = 7;</span><br><span class="line">    return x * b + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数的入口，x 将存在 edi 中，y 将存在 esi 中，返回地址将在堆栈的顶部。局部变量会被存到哪里？无论是否有足够的寄存器，一种简单的选择就是存入函数自己的栈中。</p>
<p>如果程序运行在一个实现了 ABI 标准的机器上，你可以在 rsp 保持不变的情况下获取无法在寄存器中保存的参数值和局部变量值，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">       +----------+</span><br><span class="line">rsp-24 |    a     |</span><br><span class="line">       +----------+</span><br><span class="line">rsp-16 |    b     |</span><br><span class="line">       +----------+</span><br><span class="line">rsp-8  |    c     |</span><br><span class="line">       +----------+</span><br><span class="line">rsp    | retaddr  |</span><br><span class="line">       +----------+</span><br><span class="line">rsp+8  | caller&#x27;s |</span><br><span class="line">       | stack    |</span><br><span class="line">       | frame    |</span><br><span class="line">       | ...      |</span><br><span class="line">       +----------+</span><br></pre></td></tr></table></figure>

<p>因此，我们的函数看上去是这个样子的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        global  example</span><br><span class="line">        section .text</span><br><span class="line">example:</span><br><span class="line">        mov     qword [rsp-16], 7</span><br><span class="line">        mov     rax, rdi</span><br><span class="line">        imul    rax, [rsp+8]</span><br><span class="line">        add     rax, rsi</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>如果被调用的函数需要调用其他函数，你就需要调整 rsp 的值来得到正确的返回地址。</p>
<p>在 Windows 上，您不能使用此方案，因为当中断发生时，栈指针上方的所有内容都会被抹去。而在其他大多数操作系统中，不会发生这种情况，因为在栈指针后面，有一个 128 字节的”红色区域”来保护栈指针的安全。在这种情况下，您可以立即在栈上腾出空间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">        sub rsp, 24</span><br></pre></td></tr></table></figure>

<p>因此我们的堆栈如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">       +----------+</span><br><span class="line">rsp    |    a     |</span><br><span class="line">       +----------+</span><br><span class="line">rsp+8  |    b     |</span><br><span class="line">       +----------+</span><br><span class="line">rsp+16 |    c     |</span><br><span class="line">       +----------+</span><br><span class="line">rsp+24 | retaddr  |</span><br><span class="line">       +----------+</span><br><span class="line">rsp+32 | caller&#x27;s |</span><br><span class="line">       | stack    |</span><br><span class="line">       | frame    |</span><br><span class="line">       | ...      |</span><br><span class="line">       +----------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在是这里的功能。请注意,我们必须记住在返回之前要替换栈指针！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        global  example</span><br><span class="line">        section .text</span><br><span class="line">example:</span><br><span class="line">        sub     rsp, 24</span><br><span class="line">        mov     qword [rsp+8], 7</span><br><span class="line">        mov     rax, rdi</span><br><span class="line">        imul    rax, [rsp+8]</span><br><span class="line">        add     rax, rsi</span><br><span class="line">        add     rsp, 24</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<h2 id="1-23-在-macOS-上使用-NASM"><a href="#1-23-在-macOS-上使用-NASM" class="headerlink" title="1.23. 在 macOS 上使用 NASM"></a>1.23. 在 macOS 上使用 NASM</h2><p>希望您已经使用基于 Linux 的操作系统(或更正确地说,是 ELF64 系统)阅读了以上整个教程。要使这些示例在 64 位 macOS 系统上工作,几乎只有五件事要了解：</p>
<ul>
<li>此目标文件格式<code>macho64</code>不是<code>elf64</code>。</li>
<li>系统调用值<em><strong>完全不同</strong></em>。</li>
<li>模块之间<strong>共享符号</strong>将<strong>以下划线作为前缀</strong>。</li>
<li>除非您进行一些设置调整,否则 macOS 中的 gcc 链接器似乎不允许绝对寻址。因此<code>default rel</code>,在引用标记的内存位置时添加,并且始终用<code>lea</code>获取地址。</li>
<li>另外,似乎有时在 Linux 下,不强制执行 16 位堆栈对齐要求,但似乎<em>始终</em>在 macOS 下强制执行。</li>
</ul>
<p>因此,这是上面为 macOS 编写的普通程序。</p>
<p><code>average.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line">; 64位程序,将其所有命令行参数都视为整数和</span><br><span class="line">; 将其平均值显示为浮点数。该程序使用数据</span><br><span class="line">; 存储中间结果的部分,不是必须要存储的,而仅仅是</span><br><span class="line">; 说明如何使用数据段。</span><br><span class="line">;</span><br><span class="line">; 为OS X设计。组装和运行：</span><br><span class="line">;</span><br><span class="line">; nasm -fmacho64 average.asm &amp;&amp; gcc average.o &amp;&amp; ./a.out</span><br><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line"></span><br><span class="line">        global   _main</span><br><span class="line">        extern   _atoi</span><br><span class="line">        extern   _printf</span><br><span class="line">        default  rel</span><br><span class="line"></span><br><span class="line">        section  .text</span><br><span class="line">_main:</span><br><span class="line">        push     rbx              ; 我们从未使用，但是必须的代码，对齐堆栈，以便我们调用东西</span><br><span class="line">        dec      rdi              ; argc-1, 因为我们不计算程序名称</span><br><span class="line">        jz       nothingToAverage</span><br><span class="line">        mov      [count], rdi     ; 保存实参数量</span><br><span class="line">accumulate:</span><br><span class="line">        push     rdi              ; save register across call to atoi</span><br><span class="line">        push     rsi</span><br><span class="line">        mov      rdi, [rsi+rdi*8] ; argv[rdi]</span><br><span class="line">        call     _atoi            ; now rax has the int value of arg</span><br><span class="line">        pop      rsi              ; restore registers after atoi call</span><br><span class="line">        pop      rdi</span><br><span class="line">        add      [sum], rax       ; accumulate sum as we go</span><br><span class="line">        dec      rdi              ; count down</span><br><span class="line">        jnz      accumulate       ; more arguments?</span><br><span class="line">average:</span><br><span class="line">        cvtsi2sd xmm0, [sum]</span><br><span class="line">        cvtsi2sd xmm1, [count]</span><br><span class="line">        divsd    xmm0, xmm1       ; xmm0 is sum/count</span><br><span class="line">        lea      rdi, [format]    ; 1st arg to printf</span><br><span class="line">        mov      rax, 1           ; printf is varargs, there is 1 non-int argument</span><br><span class="line">        call     _printf          ; printf(format, sum/count)</span><br><span class="line">        jmp      done</span><br><span class="line"></span><br><span class="line">nothingToAverage:</span><br><span class="line">        lea      rdi, [error]</span><br><span class="line">        xor      rax, rax</span><br><span class="line">        call     _printf</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">        pop      rbx              ; undoes the stupid push at the beginning</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">        section  .data</span><br><span class="line">count:  dq       0</span><br><span class="line">sum:    dq       0</span><br><span class="line">format: db       &quot;%g&quot;, 10, 0</span><br><span class="line">error:  db       &quot;There are no command line arguments to average&quot;, 10, 0</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -fmacho64 average.asm &amp;&amp; gcc average.o &amp;&amp; ./a.out</span></span><br><span class="line">There are no command line arguments to average</span><br><span class="line"><span class="meta">$</span><span class="bash"> nasm -fmacho64 average.asm &amp;&amp; gcc average.o &amp;&amp; ./a.out 54.3</span></span><br><span class="line">54</span><br><span class="line"><span class="meta">$</span><span class="bash"> nasm -fmacho64 average.asm &amp;&amp; gcc average.o &amp;&amp; ./a.out 54.3 -4 -3 -25 455.1111</span></span><br><span class="line">95.4</span><br></pre></td></tr></table></figure>



<h2 id="1-24-在-Windows-上使用-NASM"><a href="#1-24-在-Windows-上使用-NASM" class="headerlink" title="1.24. 在 Windows 上使用 NASM"></a>1.24. 在 Windows 上使用 NASM</h2><p>我不确定 Windows 上的 syscall 是什么,但是我确实知道,如果您要汇编和链接 C 库,则必须了解<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/7kcdt6fy.aspx">x64 约定</a>。阅读它们。您将学到以下内容：</p>
<ul>
<li>前四个整数参数在 RCX,RDX,R8 和 R9 中传递。其余的将被推入堆栈。</li>
<li>被调用者(callee)必须保留 RBX,RBP,RDI,RSI,RSP,R12,R13,R14 和 R15。</li>
<li>您猜对了，前四个浮点参数被通过 XMM0,XMM1,XMM2 和 XMM3。</li>
<li>返回值进入 RAX 或 XMM0。</li>
</ul>
<p><strong>重要说明</strong>：在任何文档中都很难找到一件事：x64 调用约定要求您在每次调用之前分配 32 字节的<a target="_blank" rel="noopener" href="http://stackoverflow.com/a/30191127/831878">影子空间</a>,并在调用之后将其删除。这意味着您的”hello world”程序如下所示：</p>
<p><code>hello.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">; -------------------------------------------------- --------------------------------------</span><br><span class="line">; 这是一个Win64控制台程序,它在一行上写入&quot; Hello&quot;,然后退出。它</span><br><span class="line">; 使用C库中的puts。编译汇编代码并运行：</span><br><span class="line">;</span><br><span class="line">; nasm -fwin64 hello.asm &amp;&amp; gcc hello.obj &amp;&amp; a</span><br><span class="line">; -------------------------------------------------- --------------------------------------</span><br><span class="line"></span><br><span class="line">        global  main</span><br><span class="line">        extern  puts</span><br><span class="line">        section .text</span><br><span class="line">main:</span><br><span class="line">        sub     rsp, 28h                        ; 保留影子空间</span><br><span class="line">        mov     rcx, message                    ; 第一个参数是message变量的地址</span><br><span class="line">        call    puts                            ; puts(message)</span><br><span class="line">        add     rsp, 28h                        ; 删除影子空间</span><br><span class="line">        ret</span><br><span class="line">message:</span><br><span class="line">        db      &#x27;Hello&#x27;, 0                      ; C strings need a zero byte at the end</span><br><span class="line">       </span><br></pre></td></tr></table></figure>

<p>您是否注意到我们实际上保留了 40 个字节？最小 32 字节的影子空间是必需的。在我们的<code>main</code>函数中,我们正在调用另一个函数,因此我们的堆栈<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/build/stack-usage">必须在 16 字节边界处对齐</a>。当<code>main</code>被调用时,返回地址(8 个字节)被压入,因此我们必须向影子空间”添加”额外的 8 个字节。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>朱辉
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2021/07/17/Note/%E7%AC%94%E8%AE%B0/NASM%E6%B1%87%E7%BC%96/Nasm%E6%8C%87%E5%8D%97/" title="">http://example.com/2021/07/17/Note/笔记/NASM汇编/Nasm指南/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/17/Note/%E7%AC%94%E8%AE%B0/Mininet/Python%20API/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/07/17/Note/%E7%AC%94%E8%AE%B0/QEMU/%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Nasm%E6%8C%87%E5%8D%97%E4%B8%AD%E6%96%87-NASM-Tutorial"><span class="nav-number">1.</span> <span class="nav-text">1. Nasm指南中文 (NASM Tutorial)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E6%95%99%E7%A8%8B%E8%8C%83%E5%9B%B4"><span class="nav-number">1.1.</span> <span class="nav-text">1.1. 教程范围</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.2.</span> <span class="nav-text">1.2. 第一个程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-NASM-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.</span> <span class="nav-text">1.3. NASM 程序的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E7%BB%86%E8%8A%82"><span class="nav-number">1.4.</span> <span class="nav-text">1.4. 细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-%E4%BB%8E%E6%8E%8C%E6%8F%A1%E5%A6%82%E4%B8%8B%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%BC%80%E5%A7%8B"><span class="nav-number">1.5.</span> <span class="nav-text">1.5. 从掌握如下汇编指令开始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-%E4%B8%89%E7%A7%8D%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="nav-number">1.6.</span> <span class="nav-text">1.6. 三种操作数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-1-%E5%AF%84%E5%AD%98%E5%99%A8%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="nav-number">1.6.1.</span> <span class="nav-text">1.6.1. 寄存器操作数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-2-%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="nav-number">1.6.2.</span> <span class="nav-text">1.6.2. 内存操作数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-3-%E7%9B%B4%E6%8E%A5%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="nav-number">1.6.3.</span> <span class="nav-text">1.6.3. 直接操作数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-%E5%85%B7%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E6%8C%87%E4%BB%A4%E9%9D%9E%E5%B8%B8%E5%B0%91%E8%A7%81"><span class="nav-number">1.7.</span> <span class="nav-text">1.7. 具有两个内存操作数的指令非常少见</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-8-%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E7%A9%BA%E9%97%B4"><span class="nav-number">1.8.</span> <span class="nav-text">1.8. 定义数据并保留空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-9-%E5%8F%A6%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="nav-number">1.9.</span> <span class="nav-text">1.9. 另一个例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-10-%E4%BD%BF%E7%94%A8-C-%E5%BA%93"><span class="nav-number">1.10.</span> <span class="nav-text">1.10. 使用 C 库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-11-%E7%90%86%E8%A7%A3%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E6%9D%9F"><span class="nav-number">1.11.</span> <span class="nav-text">1.11. 理解参数调用约束</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-12-C-%E5%92%8C%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%B7%B7%E5%90%88%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.12.</span> <span class="nav-text">1.12. C 和汇编语言混合调用示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-13-%E6%9C%89%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="nav-number">1.13.</span> <span class="nav-text">1.13. 有条件的指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-14-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-number">1.14.</span> <span class="nav-text">1.14. 命令行参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-15-%E4%B8%80%E4%B8%AA%E6%9B%B4%E9%95%BF%E4%B8%80%E4%BA%9B%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">1.15.</span> <span class="nav-text">1.15. 一个更长一些的例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-16-%E6%B5%AE%E7%82%B9%E6%95%B0%E6%8C%87%E4%BB%A4"><span class="nav-number">1.16.</span> <span class="nav-text">1.16. 浮点数指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-17-%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="nav-number">1.17.</span> <span class="nav-text">1.17. 数据段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-18-%E9%80%92%E5%BD%92"><span class="nav-number">1.18.</span> <span class="nav-text">1.18. 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-19-SIMD-%E5%B9%B6%E8%A1%8C"><span class="nav-number">1.19.</span> <span class="nav-text">1.19. SIMD 并行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-20-%E9%A5%B1%E5%92%8C%E8%BF%90%E7%AE%97"><span class="nav-number">1.20.</span> <span class="nav-text">1.20. 饱和运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-21-%E5%9B%BE%E5%BD%A2"><span class="nav-number">1.21.</span> <span class="nav-text">1.21. 图形</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-22-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%A0%86%E6%A0%88%E6%A1%86%E6%9E%B6"><span class="nav-number">1.22.</span> <span class="nav-text">1.22. 局部变量和堆栈框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-23-%E5%9C%A8-macOS-%E4%B8%8A%E4%BD%BF%E7%94%A8-NASM"><span class="nav-number">1.23.</span> <span class="nav-text">1.23. 在 macOS 上使用 NASM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-24-%E5%9C%A8-Windows-%E4%B8%8A%E4%BD%BF%E7%94%A8-NASM"><span class="nav-number">1.24.</span> <span class="nav-text">1.24. 在 Windows 上使用 NASM</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="朱辉"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">朱辉</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">129</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021-7-16 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朱辉</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">286k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:20</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
