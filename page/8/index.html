<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="zhuhui&#39;s yard">
<meta property="og:url" content="http://example.com/page/8/index.html">
<meta property="og:site_name" content="zhuhui&#39;s yard">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="朱辉">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>zhuhui's yard</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zhuhui's yard</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/17/Note/%E7%AC%94%E8%AE%B0/NASM%E6%B1%87%E7%BC%96/Nasm%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="朱辉">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhuhui's yard">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/17/Note/%E7%AC%94%E8%AE%B0/NASM%E6%B1%87%E7%BC%96/Nasm%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-17 21:04:46" itemprop="dateCreated datePublished" datetime="2021-07-17T21:04:46+08:00">2021-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-19 10:26:15" itemprop="dateModified" datetime="2021-06-19T10:26:15+08:00">2021-06-19</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-Nasm指南中文-NASM-Tutorial"><a href="#1-Nasm指南中文-NASM-Tutorial" class="headerlink" title="1. Nasm指南中文 (NASM Tutorial)"></a>1. Nasm指南中文 (NASM Tutorial)</h1><p>英文原文链接：<a target="_blank" rel="noopener" href="http://cs.lmu.edu/~ray/notes/nasmtutorial/">http://cs.lmu.edu/~ray/notes/nasmtutorial/</a><br>中文原文链接：<a target="_blank" rel="noopener" href="https://github.com/zhangjunlei26/NASM-Tutorial-CN">https://github.com/zhangjunlei26/NASM-Tutorial-CN</a></p>
<blockquote>
<p>NASM 是一个绝赞的汇编器。现在让我们通过一些例子来学习 NASM。 然而这里的笔记仅仅只是蜻蜓点水般地涉及了一些皮毛,所以当你看完这个页面后,你需要查看 <a target="_blank" rel="noopener" href="http://www.nasm.us/doc/">官方的 NASM 文档 </a>。</p>
<p>因原文写的时间应该比较早，翻译该文章是在2020年2月2日，一些链接已经不能再打开，有的示例代码在我的MAC OSX Catalina 10.15.3上也无法正常编译通过，笔者上述问题进行了修正（Linux下未进行验证）。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/zhangjunlei26/NASM-Tutorial-CN/master/assets/nasm-logo.png" alt="img"></p>
<h2 id="1-1-教程范围"><a href="#1-1-教程范围" class="headerlink" title="1.1. 教程范围"></a>1.1. 教程范围</h2><p>本教程将向您展示如何在 x86-64 体系结构上编写汇编语言程序。您将同时学会编写：</p>
<ol>
<li>独立运行的汇编程序</li>
<li> 与 C 集成的程序</li>
</ol>
<blockquote>
<p>请注意：教程会涉及Windows/MacOSX/Linux三个系统的使用方法，请确保在其中一个平台下已经安装好 nasm 和 gcc。</p>
</blockquote>
<h2 id="1-2-第一个程序"><a href="#1-2-第一个程序" class="headerlink" title="1.2. 第一个程序"></a>1.2. 第一个程序</h2><p>在学习 nasm 之前,请确保您可以键入并运行程序。</p>
<p>确保同时安装了 nasm 和 gcc。将以下程序之一另存为<code>hello.asm</code>,具体取决于您的计算机平台。然后根据给定的说明运行程序。</p>
<p>如果您使用的是基于 Linux 的操作系统：</p>
<p><code>hello.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line">; 仅使用syscall将&quot;Hello,World&quot;写入控制台。仅在64位Linux上运行。</span><br><span class="line">; 使用 Linux 下的 1 号系统调用来输出一条信息和 60 号系统调用来退出程序。</span><br><span class="line">; 编译汇编代码并运行：</span><br><span class="line">;</span><br><span class="line">; nasm -felf64 hello.asm &amp;&amp; ld hello.o &amp;&amp; ./a.out</span><br><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">          global    _start</span><br><span class="line"></span><br><span class="line">          section   .text</span><br><span class="line">_start:   </span><br><span class="line">         ; write(1, message, 13)</span><br><span class="line">          mov       rax,1                  ; 1 号系统调用是写操作</span><br><span class="line">          mov       rdi,1                  ; 1 号文件系统调用是标准输出stdout</span><br><span class="line">          mov       rsi,message            ; 输出字符串的地址</span><br><span class="line">          mov       rdx,13                 ; 字节数（输出字符串的长度）</span><br><span class="line">          syscall                           ; 调用操作系统进行写入</span><br><span class="line">          </span><br><span class="line">          ; exit(0)</span><br><span class="line">          mov       rax,60                 ; 60号系统调用是退出</span><br><span class="line">          xor       rdi,rdi                ; 退出代码 0</span><br><span class="line">          syscall                           ; 调用操作系统退出</span><br><span class="line"></span><br><span class="line">          section   .data</span><br><span class="line">message:  db        &quot;Hello,World&quot;,10      ; 注意最后的换行符</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -felf64 hello.asm &amp;&amp; ld hello.o &amp;&amp; ./a.out</span></span><br><span class="line">Hello,World</span><br></pre></td></tr></table></figure>



<p>如果您使用的是 macOS：</p>
<p><code>hello.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line">; 仅使用syscall将&quot; Hello,World&quot;写入控制台。仅在64位macOS上运行。</span><br><span class="line">;</span><br><span class="line">; 显示nasm支持的输出格式</span><br><span class="line">; nasm -hf  </span><br><span class="line">;</span><br><span class="line">; 编译汇编代码并运行：</span><br><span class="line">; nasm -fmacho64 hello.asm &amp;&amp; ld -o hello -e _main -lSystem hello.o &amp;&amp; ./hello</span><br><span class="line">; 也可以如下方式运行：</span><br><span class="line">; nasm -fmacho64 hello.asm &amp;&amp; gcc -o hello hello.o &amp;&amp; ./hello</span><br><span class="line">;</span><br><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">section .data</span><br><span class="line">  msg: db &quot;Hello, World!&quot;,10,0   ; 注意最后的换行符</span><br><span class="line">  len: equ $-msg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _main</span><br><span class="line"></span><br><span class="line">; kernel:</span><br><span class="line">;     syscall</span><br><span class="line">;     ret</span><br><span class="line"></span><br><span class="line">_main:</span><br><span class="line">    ; write(1, msg, 13)</span><br><span class="line">    mov rax,0x02000004      ; 系统调用</span><br><span class="line">    mov rdi,1               ; 文件句柄号1是stdout</span><br><span class="line">    mov rsi,msg             ; 要输出的字符串地址</span><br><span class="line">    mov rdx,len             ; 15字节数</span><br><span class="line">    ; exit(0)</span><br><span class="line">    syscall                 ; 调用操作系统进行写入</span><br><span class="line">    ; call kernel</span><br><span class="line"></span><br><span class="line">    mov rax,0x02000001      ; syscall退出</span><br><span class="line">    xor rdi,rdi             ; 退出代码0</span><br><span class="line">    syscall                 ; 调用操作系统退出</span><br><span class="line">    ; call kernel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -fmacho64 hello.asm &amp;&amp; gcc hello.o &amp;&amp; ./a.out</span></span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>练习</strong>：确定两个程序之间的差异。</p>
</blockquote>
<h2 id="1-3-NASM-程序的结构"><a href="#1-3-NASM-程序的结构" class="headerlink" title="1.3. NASM 程序的结构"></a>1.3. NASM 程序的结构</h2><p>NASM 是基于行的。大多数程序由指令后跟一个或多个部分组成。行可以具有可选标签。大多数行都有一条指令,后跟零个或多个操作数。</p>
<p><img src="https://raw.githubusercontent.com/zhangjunlei26/NASM-Tutorial-CN/master/assets/nasmstructure.png" alt="nasmstructure.png"></p>
<p>通常,您将代码放在<code>.text</code>部分中,并将常量数据放在<code>.data</code>部分中。</p>
<h2 id="1-4-细节"><a href="#1-4-细节" class="headerlink" title="1.4. 细节"></a>1.4. 细节</h2><p>NASM 是一个很棒的汇编器,但是汇编语言很复杂。您不仅需要教程。您需要详细信息。很多细节。准备咨询：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.nasm.us/doc/">NASM 手册</a>,非常好！</li>
<li><a target="_blank" rel="noopener" href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">英特尔处理器手册</a></li>
</ul>
<h2 id="1-5-从掌握如下汇编指令开始"><a href="#1-5-从掌握如下汇编指令开始" class="headerlink" title="1.5. 从掌握如下汇编指令开始"></a>1.5. 从掌握如下汇编指令开始</h2><p>有数百条指令。您无法一次全部学习它们。从这些 start:</p>
<table>
<thead>
<tr>
<th><code>mov</code> <em>x</em>,<em>y</em></th>
<th><em>x</em> ← <em>y</em></th>
</tr>
</thead>
<tbody><tr>
<td><code>and</code> <em>x</em>,<em>y</em></td>
<td><em>x</em> ← <em>x</em> and <em>y</em></td>
</tr>
<tr>
<td><code>or</code> <em>x</em>,<em>y</em></td>
<td><em>x</em> ← <em>x</em> or <em>y</em></td>
</tr>
<tr>
<td><code>xor</code> <em>x</em>,<em>y</em></td>
<td><em>x</em> ← <em>x</em> xor <em>y</em></td>
</tr>
<tr>
<td><code>add</code> <em>x</em>,<em>y</em></td>
<td><em>x</em> ← <em>x</em> + <em>y</em></td>
</tr>
<tr>
<td><code>sub</code> <em>x</em>,<em>y</em></td>
<td><em>x</em> ← <em>x</em> – <em>y</em></td>
</tr>
<tr>
<td><code>inc</code> <em>x</em></td>
<td><em>x</em> ← <em>x</em> + 1</td>
</tr>
<tr>
<td><code>dec</code> <em>x</em></td>
<td><em>x</em> ← <em>x</em> – 1</td>
</tr>
<tr>
<td><code>syscall</code></td>
<td>调用操作系统例程</td>
</tr>
<tr>
<td><code>db</code></td>
<td>一个<a target="_blank" rel="noopener" href="http://www.nasm.us/xdoc/2.11.02/html/nasmdoc3.html#section-3.2">伪指令</a> 声明字节,这将是在内存中的程序运行时</td>
</tr>
</tbody></table>
<h2 id="1-6-三种操作数"><a href="#1-6-三种操作数" class="headerlink" title="1.6. 三种操作数"></a>1.6. 三种操作数</h2><h3 id="1-6-1-寄存器操作数"><a href="#1-6-1-寄存器操作数" class="headerlink" title="1.6.1. 寄存器操作数"></a>1.6.1. 寄存器操作数</h3><p>在本教程中,我们只关心整数寄存器和 xmm 寄存器。您应该已经知道什么是寄存器,但是这里是一个快速的回顾。16 个整数寄存器为 64 位宽,称为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15</span><br><span class="line">RAX RCX RDX RBX RSP RBP RSI RDI</span><br></pre></td></tr></table></figure>

<p>(请注意,其中的最后 8 个寄存器具有备用名称)您可以将每个寄存器的最低 32 位视为寄存器本身,但可以使用以下名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R0D R1D R2D R3D R4D R5D R6D R7D R8D R9D R10D R11D R12D R13D R14D R15D</span><br><span class="line">EAX ECX EDX EBX ESP EBP ESI EDI</span><br></pre></td></tr></table></figure>

<p>您可以使用以下名称将每个寄存器的最低 16 位看作一个寄存器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R0W R1W R2W R3W R4W R5W R6W R7W R8W R9W R10W R11W R12W R13W R14W R15W</span><br><span class="line">AX CX DX BX SP BP SI DI</span><br></pre></td></tr></table></figure>

<p>您可以使用以下名称将每个寄存器的最低 8 位看作一个寄存器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R0B R1B R2B R3B R4B R5B R6B R7B R8B R9B R10B R11B R12B R13B R14B R15B</span><br><span class="line">AL CL DL BL SPL BPL SIL DIL</span><br></pre></td></tr></table></figure>

<p>由于历史原因，<code>R0...R3</code>的第 15 至 8 位被命名为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AH CH DH BH</span><br></pre></td></tr></table></figure>

<p>最后,有 16 个 XMM 寄存器,每个 128 位宽,名为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XMM0 ... XMM15</span><br></pre></td></tr></table></figure>

<p>研究这张照片;希望它可以帮助：</p>
<p><img src="https://raw.githubusercontent.com/zhangjunlei26/NASM-Tutorial-CN/master/assets/rdx.png" alt="rdx.png"></p>
<h3 id="1-6-2-内存操作数"><a href="#1-6-2-内存操作数" class="headerlink" title="1.6.2. 内存操作数"></a>1.6.2. 内存操作数</h3><p>这些是寻址的基本形式：</p>
<ul>
<li><code>[ number ]</code></li>
<li><code>[ reg ]</code></li>
<li><code>[ reg + reg*scale ]</code> <em>小数位数只能是 1、2、4 或 8</em></li>
<li><code>[ reg + number ]</code></li>
<li><code>[ reg + reg*scale + number ]</code></li>
</ul>
<p>这个数字叫做<strong>位移</strong> ; 普通寄存器称为<strong>基</strong> ; 带有刻度的寄存器称为<strong>索引</strong>。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[750]               ; 仅位移</span><br><span class="line">[rbp]               ; 仅基址寄存器</span><br><span class="line">[rcx + rsi*4]       ; 基数+指数*比例</span><br><span class="line">[rbp + rdx]         ; scale is 1</span><br><span class="line">[rbx-8]             ; 位移-8</span><br><span class="line">[rax + rdi*8 + 500] ; 所有四个组成部分</span><br><span class="line">[rbx + counter]     ; 使用变量&quot;counter&quot;地址作为偏移</span><br></pre></td></tr></table></figure>

<h3 id="1-6-3-直接操作数"><a href="#1-6-3-直接操作数" class="headerlink" title="1.6.3. 直接操作数"></a>1.6.3. 直接操作数</h3><p>这些可以用多种方式编写。以下是官方文档中的一些示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">200         ; 十进制数</span><br><span class="line">0200        ; 仍然是十进制-前导0不会使其变为八进制</span><br><span class="line">0200d       ; 显式十进制-d后缀</span><br><span class="line">0d200       ; 也十进制-0d prefex</span><br><span class="line">0c8h        ; 十六进制-h后缀,但是前导0是必需的,因为c8h看起来像var</span><br><span class="line">0xc8        ; hex-经典的0x前缀</span><br><span class="line">0hc8        ; 十六进制-由于某些原因,NASM偏爱0h写法</span><br><span class="line">310q        ; 八进制-q后缀</span><br><span class="line">0q310       ; 八进制-0q前缀</span><br><span class="line">11001000b   ; 二进制-b后缀</span><br><span class="line">0b1100_1000 ; 二进制-0b前缀,顺便说一下,允许使用下划线</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-7-具有两个内存操作数的指令非常少见"><a href="#1-7-具有两个内存操作数的指令非常少见" class="headerlink" title="1.7. 具有两个内存操作数的指令非常少见"></a>1.7. 具有两个内存操作数的指令非常少见</h2><p>实际上,在本教程中我们将看不到任何此类说明。大多数基本说明只有以下几种形式：</p>
<table>
<thead>
<tr>
<th><code>add</code> <em>reg</em>, <em>reg</em></th>
</tr>
</thead>
<tbody><tr>
<td><code>add</code> <em>reg</em>,<em>mem</em></td>
</tr>
<tr>
<td><code>add</code> <em>reg</em>, <em>imm</em></td>
</tr>
<tr>
<td><code>add</code> <em>mem</em>,<em>reg</em></td>
</tr>
<tr>
<td><code>add</code> <em>mem</em>, <em>imm</em></td>
</tr>
</tbody></table>
<h2 id="1-8-定义数据并保留空间"><a href="#1-8-定义数据并保留空间" class="headerlink" title="1.8. 定义数据并保留空间"></a>1.8. 定义数据并保留空间</h2><p>这些示例来自 <a target="_blank" rel="noopener" href="https://cs.lmu.edu/~ray/notes/nasmtutorial/">docs 的第 3 章</a>。要将数据放入内存中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db 0x55               ; 只是字节0x55</span><br><span class="line">db 0x55,0x56,0x57     ; 连续三个字节</span><br><span class="line">db &#x27;a&#x27;,0x55           ; 字符常量可以</span><br><span class="line">db &#x27;hello&#x27;,13,10,&#x27;$&#x27;  ; 字符串常量也是如此</span><br><span class="line">dw 0x1234             ; 0x34 0x12</span><br><span class="line">dw &#x27;a&#x27;                ; 0x61 0x00(只是一个数字)</span><br><span class="line">dw &#x27;ab&#x27;               ; 0x61 0x62(字符常量)</span><br><span class="line">dw &#x27;abc&#x27;              ; 0x61 0x62 0x63 0x00(字符串)</span><br><span class="line">dd 0x12345678         ; 0x78 0x56 0x34 0x12</span><br><span class="line">dd 1.234567e20        ; 浮点常数</span><br><span class="line">dq 0x123456789abcdef0 ; 八字节常量</span><br><span class="line">dq 1.234567e20        ; 双精度浮点</span><br><span class="line">dt 1.234567e20        ; 扩展精度浮点</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还有其他形式。请稍候自行查阅 NASM 文档。</p>
<p>要保留空间(无需初始化),可以使用以下伪指令。它们应该放在一个称为<code>.bss</code>的小节中(如果您试图在一个<code>.text</code>小节中使用它们,将会出现错误)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer:         resb    64              ; 保留64个字节</span><br><span class="line">wordvar:        resw    1               ; 保留一个字</span><br><span class="line">realarray:      resq    10              ; 十个实数的数组</span><br></pre></td></tr></table></figure>

<h2 id="1-9-另一个例子"><a href="#1-9-另一个例子" class="headerlink" title="1.9. 另一个例子"></a>1.9. 另一个例子</h2><p>这是一个要研究的 macOS 程序：</p>
<p><code>triangle.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line">; 这是一个OSX控制台程序,将星号的小三角形写成标准</span><br><span class="line">; 输出。仅在macOS上运行。</span><br><span class="line">;</span><br><span class="line">; nasm -fmacho64 triangle.asm &amp;&amp; gcc hola.o &amp;&amp; ./a.out</span><br><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">          global    _main</span><br><span class="line">          default  rel</span><br><span class="line"></span><br><span class="line">          section   .text</span><br><span class="line">_main:</span><br><span class="line">          push      rbx                     ; OSX必须，保存栈，Linux下删除该行</span><br><span class="line">          mov       rdx, output             ; rdx holds address of next byte to write</span><br><span class="line">          mov       r8, 1                   ; initial line length</span><br><span class="line">          mov       r9, 0                   ; number of stars written on line so far</span><br><span class="line">line:</span><br><span class="line">          mov       byte [rdx], &#x27;*&#x27;         ; write single star</span><br><span class="line">          inc       rdx                     ; advance pointer to next cell to write</span><br><span class="line">          inc       r9                      ; &quot;count&quot; number so far on line</span><br><span class="line">          cmp       r9, r8                  ; did we reach the number of stars for this line?</span><br><span class="line">          jne       line                    ; not yet, keep writing on this line</span><br><span class="line">lineDone:</span><br><span class="line">          mov       byte [rdx], 10          ; write a new line char</span><br><span class="line">          inc       rdx                     ; and move pointer to where next char goes</span><br><span class="line">          inc       r8                      ; next line will be one char longer</span><br><span class="line">          mov       r9, 0                   ; reset count of stars written on this line</span><br><span class="line">          cmp       r8, maxlines            ; wait, did we already finish the last line?</span><br><span class="line">          jng       line                    ; if not, begin writing this line</span><br><span class="line">done:</span><br><span class="line">          mov       rax, 0x02000004         ; system call for write</span><br><span class="line">          mov       rdi, 1                  ; file handle 1 is stdout</span><br><span class="line">          mov       rsi, output             ; address of string to output</span><br><span class="line">          mov       rdx, dataSize           ; number of bytes</span><br><span class="line">          syscall                           ; invoke operating system to do the write</span><br><span class="line"></span><br><span class="line">          ;exit(0)</span><br><span class="line">          pop rbx                           ; OSX必须，弹出开头保存的栈，Linux下删除该行</span><br><span class="line">          ;mov       rax, 0x02000001         ; system call for exit</span><br><span class="line">          ;xor       rdi, rdi                ; exit code 0</span><br><span class="line">          ;syscall                           ; invoke operating system to exit</span><br><span class="line">          ret</span><br><span class="line"></span><br><span class="line">          section   .bss</span><br><span class="line">maxlines  equ       8</span><br><span class="line">dataSize  equ       44</span><br><span class="line">output:   resb      dataSize</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -fmacho64 triangle.asm &amp;&amp; ld triangle.o &amp;&amp; ./a.out</span></span><br><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br><span class="line">******</span><br><span class="line">*******</span><br><span class="line">********</span><br></pre></td></tr></table></figure>



<p>此示例中的新内容：</p>
<ul>
<li><code>cmp</code> 做比较</li>
<li><code>je</code>如果先前的比较相等则跳转。</li>
<li><code>jne</code>(如果不等于则跳转)</li>
<li><code>jl</code>(如果不等于则跳转)</li>
<li><code>jnl</code>(如果不小于则跳转)</li>
<li><code>jg</code>(如果大于则跳转)</li>
<li><code>jng</code>(如果不大于则跳转)</li>
<li><code>jle</code>(如果小于或等于则跳转)</li>
<li><code>jnle</code>(如果不小于或等于则跳转)</li>
<li><code>jge</code>(如果大于或等于则跳转)</li>
<li><code>jnge</code>(如果不大于或等于则跳转)</li>
<li><code>equ</code>实际上不是真正的指令。它只是定义了供汇编程序本身使用的缩写。(这是一个意义深远的想法)</li>
<li>本<code>.bss</code>节适用于<em>可写</em>数据。</li>
</ul>
<h2 id="1-10-使用-C-库"><a href="#1-10-使用-C-库" class="headerlink" title="1.10. 使用 C 库"></a>1.10. 使用 C 库</h2><p>仅使用 syscall 编写独立程序就已经很酷了，但很少见。我们想使用 C 库中的好东西。</p>
<p>为何在 C语言程序中，看上去都是从 <code>main</code>函数开始执行？这是因为 C  library的内部有<code>_start</code>标签！<code>_start</code>开始处的代码会做一些初始化的工作，然后调用<code>main</code>函数中的代码，最后执行清理工作，最终执行60号系统调用以退出。因此，您只需要实现<code>main</code>函数即可，我们可以在汇编语言中实现这么做：</p>
<p>如果您有 Linux,请尝试以下操作：</p>
<p>hola.asm</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line">; 使用C库将&quot; Hola,mundo&quot;写入控制台。程序运行在 Linux 或者其他在 C 语言库中不使用下划线的操作系统上。</span><br><span class="line">; 如何编译执行:</span><br><span class="line">; nasm -felf64 hola.asm &amp;&amp; gcc hola.o &amp;&amp; ./a.out</span><br><span class="line">; ----------------------------------------------------------------------------------------        </span><br><span class="line">global    main</span><br><span class="line">          extern    puts</span><br><span class="line"></span><br><span class="line">          section   .text</span><br><span class="line">main:                                       ; 这里被 C library初始化代码所调用</span><br><span class="line">          mov       rdi, message            ; rdi中的第一个整数(或指针)参数</span><br><span class="line">          call      puts                    ; puts(message)</span><br><span class="line">          ret                               ; 由 main 函数返回 C 语言库例程 </span><br><span class="line">message:</span><br><span class="line">          db        &quot;Hola, mundo&quot;, 0        ; 注意字符串必须在C中以0结尾</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -felf64 hola.asm &amp;&amp; gcc hola.o &amp;&amp; ./a.out</span></span><br><span class="line">Hola, mundo</span><br></pre></td></tr></table></figure>



<p>在 macOS 下,看起来会有些不同：</p>
<p>hola.asm</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line">; 这是一个macOS控制台程序,它在一行上写入&quot; Hola,mundo&quot;,然后退出。</span><br><span class="line">; 它使用C库中的puts。编译汇编代码并运行：</span><br><span class="line">;</span><br><span class="line">; nasm -fmacho64 hola.asm &amp;&amp; gcc hola.o &amp;&amp; ./a.out</span><br><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line">          global    _main</span><br><span class="line">          extern    _puts</span><br><span class="line"></span><br><span class="line">          section   .text</span><br><span class="line">_main:    push      rbx                     ; 调用堆栈必须对齐</span><br><span class="line">          lea       rdi, [rel message]      ; 第一个参数是消息的地址</span><br><span class="line">          call      _puts                   ; puts(message)</span><br><span class="line">          pop       rbx                     ; Fix up stack before returning</span><br><span class="line">          ret</span><br><span class="line"></span><br><span class="line">          section   .data</span><br><span class="line">message:  db        &quot;Hola, mundo&quot;, 0        ; C字符串末尾需要一个零字节结尾</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -fmacho64 hola.asm &amp;&amp; gcc hola.o &amp;&amp; ./a.out</span></span><br><span class="line">Hola, mundo</span><br></pre></td></tr></table></figure>



<p>在 macOS 领域中,C 函数(或实际上是从一个模块导出到另一个模块的任何函数)必须以下划线作为前缀。调用堆栈必须在 16 字节边界上对齐(稍后会对此进行更多介绍)。并且在访问命名变量时,需要<code>rel</code>前缀。</p>
<h2 id="1-11-理解参数调用约束"><a href="#1-11-理解参数调用约束" class="headerlink" title="1.11. 理解参数调用约束"></a>1.11. 理解参数调用约束</h2><p>我们怎么知道<code>puts</code>的参数放在<code>RDI</code>中？答：有多个参数调用约定。</p>
<p>当你为 C library集成的 64 位 Linux 编写代码时，必须遵循<a href="%5Bhere%5D(https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-1.0.pdf)">《AMD64 ABI Reference》</a>中说明的调用约定 。您也可以从<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_Calling_Conventions">Wikipedia</a>获这些信息 。</p>
<blockquote>
<p>注：<code> x86-64 System V ABI</code>下载地址曾是<code>http://x86-64.org/documentation/abi.pdf</code>，现在 System V x86-64 psABI 已迁移到GitHub上维护，最新版本可以查看 <a target="_blank" rel="noopener" href="https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI">J.J. Lu的Github Wiki</a>。</p>
</blockquote>
<p>在这里列出最重要的几点：</p>
<ul>
<li>传递参数时，按照从左到右的顺序，将尽可能多的参数依次保存在寄存器中。存放位置的寄存器顺序是确定的：<ul>
<li>对于整数和指针：<code>rdi</code>,<code>rsi</code>,<code>rdx</code>,<code>rcx</code>,<code>r8</code>,<code>r9</code>。</li>
<li>对于浮点(float和double类型)：<code>xmm0</code>,<code>xmm1</code>,<code>xmm2</code>,<code>xmm3</code>,<code>xmm4</code>,<code>xmm5</code>, <code> xmm6</code>,<code>xmm7</code></li>
</ul>
</li>
<li>剩下的参数将按照从右到左的顺序压入栈中，并在调用之后 <em>由调用函数推出栈</em> 。</li>
<li>等所有的参数传入后，会生成调用指令。所以当被调用函数得到控制权后，返回地址会被保存在 <code>[rsp]</code> 中，第一个局部变量会被保存在 <code>[rsp+8]</code> 中，以此类推。</li>
<li><strong>栈指针<code>rsp</code>在调用之前，必须与16 字节边界对齐处理</strong>。当然，调用的过程中只会把一个 8 bytes 的返回地址推入栈中，所以当函数得到控制权时，<code>rsp</code> 并没有对齐。你需要向栈中压入数据或者从 <code>rsp</code> 减去 8 来使之对齐。</li>
<li>调用函数需要预留如下寄存器(the calle-save registers)：<code>rbp</code>,<code>rbx</code>,<code>r12</code>,<code>r13</code>,<code>r14</code>,<code>r15</code>。其他的寄存器可以自由使用。</li>
<li>被调用函数也需要保存 XMCSR 的控制位和 x87 指令集的控制字，但是 x87 指令在 64 位系统中很少见，所以您不必担心这一点。</li>
<li>整数被返回在<code>rax</code>或<code>rdx:rax</code>,浮点值返回在<code>xmm0</code>或<code>xmm1:xmm0</code>。</li>
</ul>
<p>以上罗列的都理解了吗？什么，还没有？没关系，接下来我们再来一些示例，练习一下。</p>
<p>如下代码，展示如何保存和恢复寄存器：</p>
<p><code>fib.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">; ----------------------------------------------------------------------------</span><br><span class="line">; 一个写入前90个斐波那契数字的64位Linux应用程序。至</span><br><span class="line">; 编译汇编代码并运行：</span><br><span class="line">;</span><br><span class="line">; nasm -felf64 fib.asm &amp;&amp; gcc fib.o &amp;&amp; ./a.out</span><br><span class="line">; ----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">        global  main</span><br><span class="line">        extern  printf</span><br><span class="line"></span><br><span class="line">        section .text</span><br><span class="line">main:</span><br><span class="line">        push rbx                               ; 我们必须保存它,因为我们使用它</span><br><span class="line"></span><br><span class="line">        mov ecx,90                             ; ecx将倒数至0</span><br><span class="line">        xor rax,rax                            ; rax将保留当前数字</span><br><span class="line">        xor rbx,rbx                            ; rbx将保留下一个数字</span><br><span class="line">        inc rbx                                ; rbx最初是1</span><br><span class="line">print:</span><br><span class="line">        ; 我们需要调用printf,但是我们使用的是rax,rbx和rcx。打印</span><br><span class="line">        ; 可能会破坏rax和rcx,因此我们将在调用之前保存它们,并且</span><br><span class="line">        ; 之后恢复它们。</span><br><span class="line"></span><br><span class="line">        push rax                               ; caller-save register</span><br><span class="line">        push rcx                               ; caller-save register</span><br><span class="line"></span><br><span class="line">        mov rdi,printf                         ; 设置第一个参数(format)</span><br><span class="line">        mov rsi,rax                            ; 设置第二个参数(current_number)</span><br><span class="line">        xor rax,rax                            ; 因为printf是varargs</span><br><span class="line"></span><br><span class="line">                                               ; 堆栈已经对齐,因为我们压入了三个8字节寄存器</span><br><span class="line">        call printf                            ; printf(format, current_number)</span><br><span class="line"></span><br><span class="line">        pop rcx                                ; restore caller-save register</span><br><span class="line">        pop rax                                ; restore caller-save register</span><br><span class="line"></span><br><span class="line">        mov rdx,rax                            ; save the current number</span><br><span class="line">        mov rax,rbx                            ; next number is now current</span><br><span class="line">        add rbx,rdx                            ; get the new next number</span><br><span class="line">        dec ecx                                ; count down</span><br><span class="line">        jnz print                              ; if not done counting, do some more</span><br><span class="line"></span><br><span class="line">        pop rbx                                ; returing之前还原rbx</span><br><span class="line">        ret</span><br><span class="line">format:</span><br><span class="line">        db  &quot;％20ld&quot;,10,0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -felf64 fib.asm &amp;&amp; gcc fib.o &amp;&amp; ./a.out</span></span><br><span class="line">                   0</span><br><span class="line">                   1</span><br><span class="line">                   1</span><br><span class="line">                   2</span><br><span class="line">                   .</span><br><span class="line">                   .</span><br><span class="line">                   .</span><br><span class="line">  679891637638612258</span><br><span class="line"> 1100087778366101931</span><br><span class="line"> 1779979416004714189</span><br></pre></td></tr></table></figure>



<p>通过如上代码，我们学习如下指令：</p>
<table>
<thead>
<tr>
<th><code>push</code> <em>x</em></th>
<th>减少<code>rsp</code>操作数的大小,然后将<em>x</em>存储在<code>[rsp]</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>pop</code> <em>x</em></td>
<td>移动<code>[rsp]</code>到<em>X</em>,然后增加<code>rsp</code>由操作数的大小</td>
</tr>
<tr>
<td><code>jnz</code> <em>label</em></td>
<td>如果设置了处理器的 Z(零)标志,请跳至给定标签</td>
</tr>
<tr>
<td><code>call</code> <em>label</em></td>
<td>按下下一条指令的地址,然后跳到标签</td>
</tr>
<tr>
<td><code>ret</code></td>
<td>弹出指令指针</td>
</tr>
</tbody></table>
<h2 id="1-12-C-和汇编语言混合调用示例"><a href="#1-12-C-和汇编语言混合调用示例" class="headerlink" title="1.12. C 和汇编语言混合调用示例"></a>1.12. C 和汇编语言混合调用示例</h2><p>该程序只是一个简单的函数,它接受三个整数参数并返回最大值。</p>
<p><code>maxofthree.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line">; 一个64位函数,该函数返回其三个64位整数的最大值</span><br><span class="line">; 论点。该函数具有签名：</span><br><span class="line">;</span><br><span class="line">; int64_t maxofthree(int64_t x,int64_t y,int64_t z)</span><br><span class="line">;</span><br><span class="line">; 请注意,参数已经在rdi,rsi和rdx中传递。我们</span><br><span class="line">; 只需返回rax中的值即可。</span><br><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line"></span><br><span class="line">        global  maxofthree</span><br><span class="line">        section .text</span><br><span class="line">maxofthree：</span><br><span class="line">        mov rax,rdi    ; 结果(rax)最初持有x</span><br><span class="line">        cmp rax,rsi    ; x小于y吗？</span><br><span class="line">        cmovl rax,rsi  ; 如果是这样,将结果设置为y</span><br><span class="line">        cmp rax,rdx    ; max(x,y)小于z吗？</span><br><span class="line">        cmovl rax,rdx  ; 如果是这样,将结果设置为z</span><br><span class="line">        ret            ; 最大值将为rax</span><br></pre></td></tr></table></figure>

<p>这是一个调用汇编语言函数的 C 程序。</p>
<p><code>callmaxofthree.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一个小程序,说明如何调用我们用汇编语言编写的maxofthree函数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">maxofthree</span> <span class="params">(<span class="keyword">int64_t</span>,<span class="keyword">int64_t</span>,<span class="keyword">int64_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, maxofthree(<span class="number">1</span>, <span class="number">-4</span>, <span class="number">-7</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, maxofthree(<span class="number">2</span>, <span class="number">-6</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, maxofthree(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, maxofthree(<span class="number">-2</span>, <span class="number">4</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, maxofthree(<span class="number">2</span>, <span class="number">-6</span>, <span class="number">5</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, maxofthree(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -felf64 maxofthree.asm &amp;&amp; gcc callmaxofthree.c maxofthree.o &amp;&amp; ./a.out</span></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure>



<h2 id="1-13-有条件的指令"><a href="#1-13-有条件的指令" class="headerlink" title="1.13. 有条件的指令"></a>1.13. 有条件的指令</h2><p>在算术或逻辑指令或比较指令之后<code>cmp</code>,处理器会设置或清除其中的位<code>rflags</code>。最有趣的标志是：</p>
<ul>
<li><code>s</code> (标志)</li>
<li><code>z</code> (零)</li>
<li><code>c</code> (携带)</li>
<li><code>o</code> (溢出)</li>
</ul>
<p>因此,执行完一条加法指令后,我们可以根据新的标志设置执行跳转,移动或设置。例如：</p>
<table>
<thead>
<tr>
<th><code>jz</code> <em>标签</em></th>
<th>如果运算结果为零,则跳至标签 L</th>
</tr>
</thead>
<tbody><tr>
<td><code>cmovno</code> <em>x</em>,<em>y</em></td>
<td><em>x ← y</em> 如果最后的操作确实<em>不</em>溢出</td>
</tr>
<tr>
<td><code>setc</code> <em>x</em></td>
<td>如果最后一个操作带有进位,则<em>x</em> ← <em>1</em>,否则,<em>x</em> ← *0,*否则(<em>x</em>必须是字节大小的寄存器或存储器位置)</td>
</tr>
</tbody></table>
<p>条件指令具有三种基本形式：<code>j</code>用于条件跳转,<code>cmov</code>用于条件移动和<code>set</code>用于条件设置。指令的后缀具有 30 种形式之一： <code>s ns z nz c nc o no p np pe po e ne l nl le nle g ng ge nge a na ae nae b nb be nbe</code>。</p>
<h2 id="1-14-命令行参数"><a href="#1-14-命令行参数" class="headerlink" title="1.14. 命令行参数"></a>1.14. 命令行参数</h2><p>在 C 中，<code>main</code> 是一个古老而简单的函数，其实它自身可以附带一些参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></span><br></pre></td></tr></table></figure>

<p>因此,您猜到了，<code>argc</code>以<code>rdi</code>结尾，而 <code>argv</code>(指针)以<code>rsi</code>结尾。下面运用这一点，实现将命令行参数简单地逐行显示的程序：</p>
<p><code>echo.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line">; 一个显示其命令行参数(每行一个)的64位程序。</span><br><span class="line">;</span><br><span class="line">; 在输入时,rdi将包含argc,而rsi将包含argv。</span><br><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line"></span><br><span class="line">        global  main</span><br><span class="line">        extern  puts</span><br><span class="line">        section .text</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">        push rdi      ; 保存 puts 函数需要用到的寄存器 </span><br><span class="line">        push rsi</span><br><span class="line">        sub rsp,8     ; 调用函数前让栈顶对齐 </span><br><span class="line"></span><br><span class="line">        mov rdi,[rsi] ; 需要输出的字符串参数 </span><br><span class="line">        call puts     ; 调用 puts 输出</span><br><span class="line"></span><br><span class="line">        add rsp,8     ; 恢复％rsp到未对齐的值</span><br><span class="line">        pop rsi       ; 恢复puts用到的寄存器</span><br><span class="line">        pop rdi</span><br><span class="line"></span><br><span class="line">        add rsi,8     ; 指向下一个参数</span><br><span class="line">        dec rdi       ; 递减参数计数</span><br><span class="line">        jnz main      ; 如果未读完参数则继续 </span><br><span class="line"></span><br><span class="line">        ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -felf64 echo.asm &amp;&amp; gcc echo.o &amp;&amp; ./a.out dog 22 -zzz <span class="string">&quot;hi there&quot;</span></span></span><br><span class="line">./a.out</span><br><span class="line">dog</span><br><span class="line">22</span><br><span class="line">-zzz</span><br><span class="line">hi there</span><br></pre></td></tr></table></figure>



<h2 id="1-15-一个更长一些的例子"><a href="#1-15-一个更长一些的例子" class="headerlink" title="1.15. 一个更长一些的例子"></a>1.15. 一个更长一些的例子</h2><p>请注意,就 C library而言, 命令行参数总是以字符串的形式传入的。如果要将参数视为整数使用，请调用<code>atoi</code>函数。下面是一个计算 $x^y$ 的函数。</p>
<p><code>power.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line">; 一个用于计算x ^ y的64位命令行应用程序。</span><br><span class="line">;</span><br><span class="line">; 语法：power x y</span><br><span class="line">; x和y均是(32位)整数</span><br><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line"></span><br><span class="line">        global  main</span><br><span class="line">        extern  printf</span><br><span class="line">        extern  puts</span><br><span class="line">        extern  atoi</span><br><span class="line"></span><br><span class="line">        section .text</span><br><span class="line">main:</span><br><span class="line">        push    r12                     ; 调用者保存寄存器 </span><br><span class="line">        push    r13</span><br><span class="line">        push    r14</span><br><span class="line">        ; 通过压入三个寄存器的值, 栈已经对齐 </span><br><span class="line"></span><br><span class="line">        cmp     rdi, 3                  ; 必须有且仅有 2 个参数</span><br><span class="line">        jne     error1</span><br><span class="line"></span><br><span class="line">        mov     r12, rsi                ; argv</span><br><span class="line"></span><br><span class="line">        ; 我们将使用 ecx 作为指数的计数器, 直至 ecx 减到 0。</span><br><span class="line">        ; 使用 esi 来保存基数, 使用 eax 保存乘积。</span><br><span class="line"></span><br><span class="line">        mov     rdi, [r12+16]           ; argv[2]</span><br><span class="line">        call    atoi                    ; y in eax</span><br><span class="line">        cmp     eax, 0                  ; 不允许负指数 </span><br><span class="line">        jl      error2</span><br><span class="line">        mov     r13d, eax               ; y in r13d</span><br><span class="line"></span><br><span class="line">        mov     rdi, [r12+8]            ; argv</span><br><span class="line">        call    atoi                    ; x in eax</span><br><span class="line">        mov     r14d, eax               ; x in r14d</span><br><span class="line"></span><br><span class="line">        mov     eax, 1                  ; 初始结果 start with answer = 1</span><br><span class="line">check:</span><br><span class="line">        test    r13d, r13d              ; 递减 y 直至 0</span><br><span class="line">        jz      gotit                   ; done</span><br><span class="line">        imul    eax, r14d               ; 再乘上一个 x</span><br><span class="line">        dec     r13d</span><br><span class="line">        jmp     check</span><br><span class="line">gotit:                                  ; print report on success</span><br><span class="line">        mov     rdi, answer</span><br><span class="line">        movsxd  rsi, eax</span><br><span class="line">        xor     rax, rax</span><br><span class="line">        call    printf</span><br><span class="line">        jmp     done</span><br><span class="line">error1:                                 ; print error message</span><br><span class="line">        mov     edi, badArgumentCount</span><br><span class="line">        call    puts</span><br><span class="line">        jmp     done</span><br><span class="line">error2:                                 ; print error message</span><br><span class="line">        mov     edi, negativeExponent</span><br><span class="line">        call    puts</span><br><span class="line">done:                                   ; restore saved registers</span><br><span class="line">        pop     r14</span><br><span class="line">        pop     r13</span><br><span class="line">        pop     r12</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">answer:</span><br><span class="line">        db      &quot;%d&quot;, 10, 0</span><br><span class="line">badArgumentCount:</span><br><span class="line">        db      &quot;Requires exactly two arguments&quot;, 10, 0</span><br><span class="line">negativeExponent:</span><br><span class="line">        db      &quot;The exponent may not be negative&quot;, 10, 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -felf64 power.asm &amp;&amp; gcc -o power power.o</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./power 2 19</span></span><br><span class="line">524288</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./power 3 -8</span></span><br><span class="line">The exponent may not be negative</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./power 1 500</span></span><br><span class="line">1</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./power 1</span></span><br><span class="line">Requires exactly two arguments</span><br></pre></td></tr></table></figure>



<h2 id="1-16-浮点数指令"><a href="#1-16-浮点数指令" class="headerlink" title="1.16. 浮点数指令"></a>1.16. 浮点数指令</h2><p>浮点数参数保存在 xmm 寄存器中。下面是一个用来计算存放在数组中的浮点数的和的简单的函数：</p>
<p><code>sum.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line">; 一个64位程序,该函数返回浮点数数组元素之和</span><br><span class="line">; 函数声明如下：</span><br><span class="line">;</span><br><span class="line">; double sum(double []array,uint64_t length)</span><br><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line"></span><br><span class="line">        global  sum</span><br><span class="line">        section .text</span><br><span class="line">sum:</span><br><span class="line">        xorpd   xmm0, xmm0              ; 初始化累加和为 0</span><br><span class="line">        cmp     rsi, 0                  ; 考虑数组长度为 0 的特殊情形 </span><br><span class="line">        je      done</span><br><span class="line">next:</span><br><span class="line">        addsd   xmm0, [rdi]             ; 累加当前数组元素的值 </span><br><span class="line">        add     rdi, 8                  ; 指向下一个数组元素</span><br><span class="line">        dec     rsi                     ; 计数器递减</span><br><span class="line">        jnz     next                    ; 如果计数器未归0，则继续累加 </span><br><span class="line">done:</span><br><span class="line">        ret                             ; 返回保存在 xmm0 寄存器中的值 </span><br></pre></td></tr></table></figure>

<p>请注意,浮点指令具有<code>sd</code>后缀;这是最常见的一种,但稍后我们会再看到其他一些。这是一个调用它的 C 程序：</p>
<p><code>callum.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明如何调用用汇编语言编写的sum函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span>[], <span class="keyword">uint64_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> test[] = &#123;</span><br><span class="line">        <span class="number">40.5</span>, <span class="number">26.7</span>, <span class="number">21.9</span>, <span class="number">1.5</span>, <span class="number">-40.5</span>, <span class="number">-23.4</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%20.7f\n&quot;</span>, sum(test, <span class="number">6</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%20.7f\n&quot;</span>, sum(test, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%20.7f\n&quot;</span>, sum(test, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%20.7f\n&quot;</span>, sum(test, <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -felf64 sum.asm &amp;&amp; gcc sum.o callsum.c &amp;&amp; ./a.out</span></span><br><span class="line">          26.7000000</span><br><span class="line">          67.2000000</span><br><span class="line">           0.0000000</span><br><span class="line">          89.1000000</span><br></pre></td></tr></table></figure>



<h2 id="1-17-数据段"><a href="#1-17-数据段" class="headerlink" title="1.17. 数据段"></a>1.17. 数据段</h2><p>在大多数操作系统上,.data 数据段是只读的,所以你需要使用数据段。.data 部分仅仅用来初始化数据，而您还可以发现有一个特殊的.bss 的段，是用来存放未初始化过的数据的下面是一个程序用来计算通过命令行参数传递的整数的平均值，并且以浮点数输出结果的程序。</p>
<p><code>average.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line">; 一个把参数当做整数处理, 并且以浮点数形式输出他们平均值的 64 位程序。</span><br><span class="line">; 这个程序将使用一个数据段来保存中间结果。</span><br><span class="line">; 这不是必须的, 但是在此我们想展示数据段是如何使用的。</span><br><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line"></span><br><span class="line">        global   main</span><br><span class="line">        extern   atoi</span><br><span class="line">        extern   printf</span><br><span class="line">        default  rel</span><br><span class="line"></span><br><span class="line">        section  .text</span><br><span class="line">main:</span><br><span class="line">        dec      rdi              ; argc-1,因为我们不计算程序名称</span><br><span class="line">        jz       nothingToAverage</span><br><span class="line">        mov      [count], rdi     ; 保存浮点数参数的个数 </span><br><span class="line">accumulate:</span><br><span class="line">        push     rdi              ; 保存调用 atoi 需要使用的寄存器 </span><br><span class="line">        push     rsi</span><br><span class="line">        mov      rdi, [rsi+rdi*8] ; argv[rdi]</span><br><span class="line">        call     atoi             ; 现在 rax 里保存着 arg 的整数值 </span><br><span class="line">        pop      rsi              ; 调用完 atoi 函数后恢复寄存器 </span><br><span class="line">        pop      rdi</span><br><span class="line">        add      [sum], rax       ; 继续累加 </span><br><span class="line">        dec      rdi              ; 递减 </span><br><span class="line">        jnz      accumulate       ; 还有参数吗?</span><br><span class="line">average:</span><br><span class="line">        cvtsi2sd xmm0, [sum]</span><br><span class="line">        cvtsi2sd xmm1, [count]</span><br><span class="line">        divsd    xmm0, xmm1       ; xmm0 现在值为 sum/count</span><br><span class="line">        mov      rdi, format      ; printf 的第一个参数 [注: 输出格式]</span><br><span class="line">        mov      rax, 1           ; printf 是多参数的, 含有一个不是整数的参数 </span><br><span class="line"></span><br><span class="line">        sub      rsp, 8           ; 对齐栈指针 </span><br><span class="line">        call     printf           ; printf(format, sum/count)</span><br><span class="line">        add      rsp, 8           ; 恢复栈指针 </span><br><span class="line"></span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">nothingToAverage:</span><br><span class="line">        mov      rdi, error</span><br><span class="line">        xor      rax, rax</span><br><span class="line">        call     printf</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">        section  .data</span><br><span class="line">count:  dq       0</span><br><span class="line">sum:    dq       0</span><br><span class="line">format: db       &quot;%g&quot;, 10, 0</span><br><span class="line">error:  db       &quot;There are no command line arguments to average&quot;, 10, 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -felf64 average.asm &amp;&amp; gcc average.o &amp;&amp; ./a.out 19 8 21 -33</span></span><br><span class="line">3.75</span><br><span class="line"><span class="meta">$</span><span class="bash"> nasm -felf64 average.asm &amp;&amp; gcc average.o &amp;&amp; ./a.out</span></span><br><span class="line">There are no command line arguments to average</span><br></pre></td></tr></table></figure>



<p>该程序着重介绍了一些在整数和浮点值之间转换的处理器指令。一些最常见的是：</p>
<table>
<thead>
<tr>
<th><code>cvtsi2sd</code> <em>xmmreg,r/m32</em></th>
<th><em>xmmreg [63..0]</em> ← <em>intToDouble(r / m32)</em></th>
</tr>
</thead>
<tbody><tr>
<td><code>cvtsi2ss</code> <em>xmmreg,r/m32</em></td>
<td><em>xmmreg [31..0]</em> ← <em>intToFloat(r / m32)</em></td>
</tr>
<tr>
<td><code>cvtsd2si</code> <em>reg32</em>,<em>xmmr/m64</em></td>
<td><em>reg32</em> ← <em>doubleToInt(xmmr / m64)</em></td>
</tr>
<tr>
<td><code>cvtss2si</code> <em>reg32</em>,<em>xmmr/m32</em></td>
<td><em>reg32</em> ← <em>floatToInt(xmmr / m32)</em></td>
</tr>
</tbody></table>
<h2 id="1-18-递归"><a href="#1-18-递归" class="headerlink" title="1.18. 递归"></a>1.18. 递归</h2><p>也许令人惊讶的是,实现递归功能并没有什么不同寻常的。您只需要像往常一样小心保存寄存器的状态即可。在递归调用周围推动和弹出是一种典型的策略。</p>
<p><code>factorial.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">; ----------------------------------------------------------------------------</span><br><span class="line">; 一种递归函数的实现：</span><br><span class="line">;</span><br><span class="line">;   uint64_t factorial(uint64_t n) &#123;</span><br><span class="line">;       return (n &lt;= 1) ? 1 : n * factorial(n-1);</span><br><span class="line">;   &#125;</span><br><span class="line">; ----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">        global  factorial</span><br><span class="line"></span><br><span class="line">        section .text</span><br><span class="line">factorial:</span><br><span class="line">        cmp     rdi, 1                  ; n &lt;= 1?</span><br><span class="line">        jnbe    L1                      ; 如果不是, 进行递归调用 </span><br><span class="line">        mov     rax, 1                  ; 否则, 返回 1</span><br><span class="line">        ret</span><br><span class="line">L1:</span><br><span class="line">        push    rdi                     ; 将n保存在堆栈上 (同时对齐 %rsp!)</span><br><span class="line">        dec     rdi                     ; n-1</span><br><span class="line">        call    factorial               ; factorial(n-1), 返回值保保存到 %rax</span><br><span class="line">        pop     rdi                     ; 恢复 n</span><br><span class="line">        imul    rax, rdi                ; n * factorial(n-1), 保存到 %rax</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>一个调用示例：</p>
<p><code>callfactorial.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *这是一个调用外部定义的阶乘函数的程序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">factorial</span><span class="params">(<span class="keyword">uint64_t</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint64_t</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;factorial(%2lu) = %lu\n&quot;</span>, i, factorial(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -felf64 factorial.asm &amp;&amp; gcc -std=c99 factorial.o callfactorial.c &amp;&amp; ./a.out</span></span><br><span class="line">factorial( 0) = 1</span><br><span class="line">factorial( 1) = 1</span><br><span class="line">factorial( 2) = 2</span><br><span class="line">factorial( 3) = 6</span><br><span class="line">factorial( 4) = 24</span><br><span class="line">factorial( 5) = 120</span><br><span class="line">factorial( 6) = 720</span><br><span class="line">factorial( 7) = 5040</span><br><span class="line">factorial( 8) = 40320</span><br><span class="line">factorial( 9) = 362880</span><br><span class="line">factorial(10) = 3628800</span><br><span class="line">factorial(11) = 39916800</span><br><span class="line">factorial(12) = 479001600</span><br><span class="line">factorial(13) = 6227020800</span><br><span class="line">factorial(14) = 87178291200</span><br><span class="line">factorial(15) = 1307674368000</span><br><span class="line">factorial(16) = 20922789888000</span><br><span class="line">factorial(17) = 355687428096000</span><br><span class="line">factorial(18) = 6402373705728000</span><br><span class="line">factorial(19) = 121645100408832000</span><br></pre></td></tr></table></figure>



<h2 id="1-19-SIMD-并行"><a href="#1-19-SIMD-并行" class="headerlink" title="1.19. SIMD 并行"></a>1.19. SIMD 并行</h2><p>XMM 寄存器可以对浮点值进行一次算术运算(一次标量)或一次执行多次运算(打包)。操作具有以下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op xmmreg_or_memory,xmmreg</span><br></pre></td></tr></table></figure>

<p>对于浮点加法,说明如下：</p>
<table>
<thead>
<tr>
<th><code>addpd</code></th>
<th>并行执行 2 个双精度加法（添加压缩双精度）</th>
</tr>
</thead>
<tbody><tr>
<td><code>addsd</code></td>
<td>使用寄存器的低 64 位仅执行一次双精度加法（将标量加倍）</td>
</tr>
<tr>
<td><code>addps</code></td>
<td>并行执行 4 个单精度加法（添加打包的单个）</td>
</tr>
<tr>
<td><code>addss</code></td>
<td>使用寄存器的低 32 位仅执行一个单精度加法（加标量单）</td>
</tr>
</tbody></table>
<p>这是一个可以一次添加四个浮点数的函数：</p>
<p><code>add_four_floats.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">; void add_four_floats(float x[4], float y[4])</span><br><span class="line">; x[i] += y[i] for i in range(0..4)</span><br><span class="line"></span><br><span class="line">        global   add_four_floats</span><br><span class="line">        section  .text</span><br><span class="line"></span><br><span class="line">add_four_floats:</span><br><span class="line">        movdqa   xmm0, [rdi]            ; x的所有四个值</span><br><span class="line">        movdqa   xmm1, [rsi]            ; y的所有四个值</span><br><span class="line">        addps    xmm0, xmm1             ; 一次完成所有四个总和</span><br><span class="line">        movdqa   [rdi], xmm0</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>一个呼叫者：</p>
<p><code>test_add_four_floats.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_four_floats</span><span class="params">(<span class="keyword">float</span>[], <span class="keyword">float</span>[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> x[] = &#123;<span class="number">-29.750</span>, <span class="number">244.333</span>, <span class="number">887.29</span>, <span class="number">48.1E22</span>&#125;;</span><br><span class="line">    <span class="keyword">float</span> y[] = &#123;<span class="number">29.750</span>,  <span class="number">199.333</span>, <span class="number">-8.29</span>,  <span class="number">22.1E23</span>&#125;;</span><br><span class="line">    add_four_floats(x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n%f\n%f\n%f\n&quot;</span>, x[<span class="number">0</span>], x[<span class="number">1</span>], x[<span class="number">2</span>], x[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以参考：<a target="_blank" rel="noopener" href="http://rayseyfarth.com/asm/pdf/ch11-floating-point.pdf">nice little x86 floating-point slide deck from Ray Seyfarth</a></p>
<h2 id="1-20-饱和运算"><a href="#1-20-饱和运算" class="headerlink" title="1.20. 饱和运算"></a>1.20. 饱和运算</h2><p>XMM 寄存器还可以对整数进行算术运算。这些说明具有以下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op xmmreg_or_memory, xmmreg</span><br></pre></td></tr></table></figure>

<p>对于整数加法,说明如下：</p>
<table>
<thead>
<tr>
<th><code>paddb</code></th>
<th>做 16 个字节加法</th>
</tr>
</thead>
<tbody><tr>
<td><code>paddw</code></td>
<td>做 8 个单词加法</td>
</tr>
<tr>
<td><code>paddd</code></td>
<td>做 4 个 dword 加法</td>
</tr>
<tr>
<td><code>paddq</code></td>
<td>做 2 个 qword 加法</td>
</tr>
<tr>
<td><code>paddsb</code></td>
<td>执行 16 个字节加法并带符号饱和度（80..7F）</td>
</tr>
<tr>
<td><code>paddsw</code></td>
<td>进行 8 个带符号饱和的单词加法（8000..7F）</td>
</tr>
<tr>
<td><code>paddusb</code></td>
<td>执行 16 个字节的无符号饱和（00..FF）</td>
</tr>
<tr>
<td><code>paddusw</code></td>
<td>进行 8 个无符号饱和（00..FFFF）的单词加法</td>
</tr>
</tbody></table>
<p>这是一个例子。它还说明了如何加载 XMM 寄存器。您无法加载立即值;您必须使用它<code>movaps</code>来移出内存。还有其他方法,但是我们不会在本教程中介绍所有内容。</p>
<p><code>satexample.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line">; 有符号饱和运算示例。</span><br><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line">        global  main</span><br><span class="line">        extern  printf</span><br><span class="line"></span><br><span class="line">        section .text</span><br><span class="line">main:</span><br><span class="line">        push    rbp</span><br><span class="line">        movaps  xmm0, [arg1]</span><br><span class="line">        movaps  xmm1, [arg2]</span><br><span class="line">        paddsw  xmm0, xmm1</span><br><span class="line">        movaps  [result], xmm0</span><br><span class="line"></span><br><span class="line">        lea     rdi, [format]</span><br><span class="line">        mov     esi, dword [result]</span><br><span class="line">        mov     edx, dword [result+4]</span><br><span class="line">        mov     ecx, dword [result+8]</span><br><span class="line">        mov     r8d, dword [result+12]</span><br><span class="line">        xor     rax, rax</span><br><span class="line">        call    printf</span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br><span class="line">        section .data</span><br><span class="line">        align   16</span><br><span class="line">arg1:   dw      0x3544,0x24FF,0x7654,0x9A77,0xF677,0x9000,0xFFFF,0x0000</span><br><span class="line">arg2:   dw      0x7000,0x1000,0xC000,0x1000,0xB000,0xA000,0x1000,0x0000</span><br><span class="line">result: dd      0, 0, 0, 0</span><br><span class="line">format: db      &#x27;%x%x%x%x&#x27;,10,0</span><br></pre></td></tr></table></figure>



<h2 id="1-21-图形"><a href="#1-21-图形" class="headerlink" title="1.21. 图形"></a>1.21. 图形</h2><p>TODO</p>
<h2 id="1-22-局部变量和堆栈框架"><a href="#1-22-局部变量和堆栈框架" class="headerlink" title="1.22. 局部变量和堆栈框架"></a>1.22. 局部变量和堆栈框架</h2><p>首先,请阅读<a target="_blank" rel="noopener" href="http://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64/">Eli Bendersky 的文章,</a> 该概述比我的简短笔记更完整。</p>
<p>调用函数时,调用者将首先将参数存入正确的寄存器中，然后发出<code>call</code>指令。调用之前,超出寄存器覆盖范围的其他参数将被推入栈中。所调用的指令会把返回地址存入栈顶。所以如果有以下的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int64_t example(int64_t x, int64_t y) &#123;</span><br><span class="line">    int64_t a, b, c;</span><br><span class="line">    b = 7;</span><br><span class="line">    return x * b + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数的入口，x 将存在 edi 中，y 将存在 esi 中，返回地址将在堆栈的顶部。局部变量会被存到哪里？无论是否有足够的寄存器，一种简单的选择就是存入函数自己的栈中。</p>
<p>如果程序运行在一个实现了 ABI 标准的机器上，你可以在 rsp 保持不变的情况下获取无法在寄存器中保存的参数值和局部变量值，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">       +----------+</span><br><span class="line">rsp-24 |    a     |</span><br><span class="line">       +----------+</span><br><span class="line">rsp-16 |    b     |</span><br><span class="line">       +----------+</span><br><span class="line">rsp-8  |    c     |</span><br><span class="line">       +----------+</span><br><span class="line">rsp    | retaddr  |</span><br><span class="line">       +----------+</span><br><span class="line">rsp+8  | caller&#x27;s |</span><br><span class="line">       | stack    |</span><br><span class="line">       | frame    |</span><br><span class="line">       | ...      |</span><br><span class="line">       +----------+</span><br></pre></td></tr></table></figure>

<p>因此，我们的函数看上去是这个样子的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        global  example</span><br><span class="line">        section .text</span><br><span class="line">example:</span><br><span class="line">        mov     qword [rsp-16], 7</span><br><span class="line">        mov     rax, rdi</span><br><span class="line">        imul    rax, [rsp+8]</span><br><span class="line">        add     rax, rsi</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>如果被调用的函数需要调用其他函数，你就需要调整 rsp 的值来得到正确的返回地址。</p>
<p>在 Windows 上，您不能使用此方案，因为当中断发生时，栈指针上方的所有内容都会被抹去。而在其他大多数操作系统中，不会发生这种情况，因为在栈指针后面，有一个 128 字节的”红色区域”来保护栈指针的安全。在这种情况下，您可以立即在栈上腾出空间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">        sub rsp, 24</span><br></pre></td></tr></table></figure>

<p>因此我们的堆栈如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">       +----------+</span><br><span class="line">rsp    |    a     |</span><br><span class="line">       +----------+</span><br><span class="line">rsp+8  |    b     |</span><br><span class="line">       +----------+</span><br><span class="line">rsp+16 |    c     |</span><br><span class="line">       +----------+</span><br><span class="line">rsp+24 | retaddr  |</span><br><span class="line">       +----------+</span><br><span class="line">rsp+32 | caller&#x27;s |</span><br><span class="line">       | stack    |</span><br><span class="line">       | frame    |</span><br><span class="line">       | ...      |</span><br><span class="line">       +----------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在是这里的功能。请注意,我们必须记住在返回之前要替换栈指针！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        global  example</span><br><span class="line">        section .text</span><br><span class="line">example:</span><br><span class="line">        sub     rsp, 24</span><br><span class="line">        mov     qword [rsp+8], 7</span><br><span class="line">        mov     rax, rdi</span><br><span class="line">        imul    rax, [rsp+8]</span><br><span class="line">        add     rax, rsi</span><br><span class="line">        add     rsp, 24</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<h2 id="1-23-在-macOS-上使用-NASM"><a href="#1-23-在-macOS-上使用-NASM" class="headerlink" title="1.23. 在 macOS 上使用 NASM"></a>1.23. 在 macOS 上使用 NASM</h2><p>希望您已经使用基于 Linux 的操作系统(或更正确地说,是 ELF64 系统)阅读了以上整个教程。要使这些示例在 64 位 macOS 系统上工作,几乎只有五件事要了解：</p>
<ul>
<li>此目标文件格式<code>macho64</code>不是<code>elf64</code>。</li>
<li>系统调用值<em><strong>完全不同</strong></em>。</li>
<li>模块之间<strong>共享符号</strong>将<strong>以下划线作为前缀</strong>。</li>
<li>除非您进行一些设置调整,否则 macOS 中的 gcc 链接器似乎不允许绝对寻址。因此<code>default rel</code>,在引用标记的内存位置时添加,并且始终用<code>lea</code>获取地址。</li>
<li>另外,似乎有时在 Linux 下,不强制执行 16 位堆栈对齐要求,但似乎<em>始终</em>在 macOS 下强制执行。</li>
</ul>
<p>因此,这是上面为 macOS 编写的普通程序。</p>
<p><code>average.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line">; 64位程序,将其所有命令行参数都视为整数和</span><br><span class="line">; 将其平均值显示为浮点数。该程序使用数据</span><br><span class="line">; 存储中间结果的部分,不是必须要存储的,而仅仅是</span><br><span class="line">; 说明如何使用数据段。</span><br><span class="line">;</span><br><span class="line">; 为OS X设计。组装和运行：</span><br><span class="line">;</span><br><span class="line">; nasm -fmacho64 average.asm &amp;&amp; gcc average.o &amp;&amp; ./a.out</span><br><span class="line">; -------------------------------------------------- ---------------------------</span><br><span class="line"></span><br><span class="line">        global   _main</span><br><span class="line">        extern   _atoi</span><br><span class="line">        extern   _printf</span><br><span class="line">        default  rel</span><br><span class="line"></span><br><span class="line">        section  .text</span><br><span class="line">_main:</span><br><span class="line">        push     rbx              ; 我们从未使用，但是必须的代码，对齐堆栈，以便我们调用东西</span><br><span class="line">        dec      rdi              ; argc-1, 因为我们不计算程序名称</span><br><span class="line">        jz       nothingToAverage</span><br><span class="line">        mov      [count], rdi     ; 保存实参数量</span><br><span class="line">accumulate:</span><br><span class="line">        push     rdi              ; save register across call to atoi</span><br><span class="line">        push     rsi</span><br><span class="line">        mov      rdi, [rsi+rdi*8] ; argv[rdi]</span><br><span class="line">        call     _atoi            ; now rax has the int value of arg</span><br><span class="line">        pop      rsi              ; restore registers after atoi call</span><br><span class="line">        pop      rdi</span><br><span class="line">        add      [sum], rax       ; accumulate sum as we go</span><br><span class="line">        dec      rdi              ; count down</span><br><span class="line">        jnz      accumulate       ; more arguments?</span><br><span class="line">average:</span><br><span class="line">        cvtsi2sd xmm0, [sum]</span><br><span class="line">        cvtsi2sd xmm1, [count]</span><br><span class="line">        divsd    xmm0, xmm1       ; xmm0 is sum/count</span><br><span class="line">        lea      rdi, [format]    ; 1st arg to printf</span><br><span class="line">        mov      rax, 1           ; printf is varargs, there is 1 non-int argument</span><br><span class="line">        call     _printf          ; printf(format, sum/count)</span><br><span class="line">        jmp      done</span><br><span class="line"></span><br><span class="line">nothingToAverage:</span><br><span class="line">        lea      rdi, [error]</span><br><span class="line">        xor      rax, rax</span><br><span class="line">        call     _printf</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">        pop      rbx              ; undoes the stupid push at the beginning</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">        section  .data</span><br><span class="line">count:  dq       0</span><br><span class="line">sum:    dq       0</span><br><span class="line">format: db       &quot;%g&quot;, 10, 0</span><br><span class="line">error:  db       &quot;There are no command line arguments to average&quot;, 10, 0</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nasm -fmacho64 average.asm &amp;&amp; gcc average.o &amp;&amp; ./a.out</span></span><br><span class="line">There are no command line arguments to average</span><br><span class="line"><span class="meta">$</span><span class="bash"> nasm -fmacho64 average.asm &amp;&amp; gcc average.o &amp;&amp; ./a.out 54.3</span></span><br><span class="line">54</span><br><span class="line"><span class="meta">$</span><span class="bash"> nasm -fmacho64 average.asm &amp;&amp; gcc average.o &amp;&amp; ./a.out 54.3 -4 -3 -25 455.1111</span></span><br><span class="line">95.4</span><br></pre></td></tr></table></figure>



<h2 id="1-24-在-Windows-上使用-NASM"><a href="#1-24-在-Windows-上使用-NASM" class="headerlink" title="1.24. 在 Windows 上使用 NASM"></a>1.24. 在 Windows 上使用 NASM</h2><p>我不确定 Windows 上的 syscall 是什么,但是我确实知道,如果您要汇编和链接 C 库,则必须了解<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/7kcdt6fy.aspx">x64 约定</a>。阅读它们。您将学到以下内容：</p>
<ul>
<li>前四个整数参数在 RCX,RDX,R8 和 R9 中传递。其余的将被推入堆栈。</li>
<li>被调用者(callee)必须保留 RBX,RBP,RDI,RSI,RSP,R12,R13,R14 和 R15。</li>
<li>您猜对了，前四个浮点参数被通过 XMM0,XMM1,XMM2 和 XMM3。</li>
<li>返回值进入 RAX 或 XMM0。</li>
</ul>
<p><strong>重要说明</strong>：在任何文档中都很难找到一件事：x64 调用约定要求您在每次调用之前分配 32 字节的<a target="_blank" rel="noopener" href="http://stackoverflow.com/a/30191127/831878">影子空间</a>,并在调用之后将其删除。这意味着您的”hello world”程序如下所示：</p>
<p><code>hello.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">; -------------------------------------------------- --------------------------------------</span><br><span class="line">; 这是一个Win64控制台程序,它在一行上写入&quot; Hello&quot;,然后退出。它</span><br><span class="line">; 使用C库中的puts。编译汇编代码并运行：</span><br><span class="line">;</span><br><span class="line">; nasm -fwin64 hello.asm &amp;&amp; gcc hello.obj &amp;&amp; a</span><br><span class="line">; -------------------------------------------------- --------------------------------------</span><br><span class="line"></span><br><span class="line">        global  main</span><br><span class="line">        extern  puts</span><br><span class="line">        section .text</span><br><span class="line">main:</span><br><span class="line">        sub     rsp, 28h                        ; 保留影子空间</span><br><span class="line">        mov     rcx, message                    ; 第一个参数是message变量的地址</span><br><span class="line">        call    puts                            ; puts(message)</span><br><span class="line">        add     rsp, 28h                        ; 删除影子空间</span><br><span class="line">        ret</span><br><span class="line">message:</span><br><span class="line">        db      &#x27;Hello&#x27;, 0                      ; C strings need a zero byte at the end</span><br><span class="line">       </span><br></pre></td></tr></table></figure>

<p>您是否注意到我们实际上保留了 40 个字节？最小 32 字节的影子空间是必需的。在我们的<code>main</code>函数中,我们正在调用另一个函数,因此我们的堆栈<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/build/stack-usage">必须在 16 字节边界处对齐</a>。当<code>main</code>被调用时,返回地址(8 个字节)被压入,因此我们必须向影子空间”添加”额外的 8 个字节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/17/Note/%E7%AC%94%E8%AE%B0/Mininet/Python%20API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="朱辉">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhuhui's yard">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/17/Note/%E7%AC%94%E8%AE%B0/Mininet/Python%20API/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-17 21:04:46" itemprop="dateCreated datePublished" datetime="2021-07-17T21:04:46+08:00">2021-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-19 10:26:15" itemprop="dateModified" datetime="2021-06-19T10:26:15+08:00">2021-06-19</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>286</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-Python-API"><a href="#1-Python-API" class="headerlink" title="1. Python API"></a>1. Python API</h1><h2 id="1-1-mininet-topo类"><a href="#1-1-mininet-topo类" class="headerlink" title="1.1. mininet.topo类"></a>1.1. mininet.topo类</h2><ul>
<li>用于存储网络的拓扑结构的类</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>参数</th>
<th>返回值</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td><code>addNode(self, name, **opts)</code></td>
<td><code>name</code>：节点的名称<br><code>opts</code>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<code>mac</code><br>&nbsp;&nbsp;&nbsp;&nbsp;<code>ip</code><br>&nbsp;&nbsp;&nbsp;&nbsp;<code>defaultRoute</code><br>&nbsp;&nbsp;&nbsp;&nbsp;<code>lo</code></td>
<td>节点名称</td>
<td></td>
</tr>
<tr>
<td><code>addHost(self, name, **opts)</code></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>addSwitch(self, name, **opts)</code></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>addLink(self, name, **opts)</code></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/17/Note/%E7%AC%94%E8%AE%B0/NASM%E6%B1%87%E7%BC%96/01.Nasm%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="朱辉">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhuhui's yard">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/17/Note/%E7%AC%94%E8%AE%B0/NASM%E6%B1%87%E7%BC%96/01.Nasm%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-17 21:04:46" itemprop="dateCreated datePublished" datetime="2021-07-17T21:04:46+08:00">2021-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-19 10:26:15" itemprop="dateModified" datetime="2021-06-19T10:26:15+08:00">2021-06-19</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>251</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Nasm代码格式"><a href="#Nasm代码格式" class="headerlink" title="Nasm代码格式"></a>Nasm代码格式</h1><hr>
<p><code>nasm</code>指令包含机器指令，宏指令和伪指令，机器指令格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label:    instruction operands ;comment</span><br></pre></td></tr></table></figure>
<p>四种成分在某些情况下均为可选值，具体情况具体对待。<br>当一行代码写不开时，在末尾使用<code>\</code>表示换行<br>Nasm在程序行中对空格没有要求，label前后都可有空格，并且之后的冒号<code>:</code>是可选的<br>标识符的命名规则为，由字母，数字和<code>_</code>，<code>$</code>，<code>#</code>，<code>@</code>，<code>~</code>，<code>.</code>，<code>?</code>组成，可以以字母，<code>.</code>（具有特殊意义），<code>_</code>，<code>?</code>开头。<br>可以在标识符前加<code>$</code>来区分标识符和其他重名寄存器、指令等。最长4095个字符</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/17/Note/%E7%AC%94%E8%AE%B0/NASM%E6%B1%87%E7%BC%96/07.Assembler%20Directives/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="朱辉">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhuhui's yard">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/17/Note/%E7%AC%94%E8%AE%B0/NASM%E6%B1%87%E7%BC%96/07.Assembler%20Directives/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-17 21:04:46" itemprop="dateCreated datePublished" datetime="2021-07-17T21:04:46+08:00">2021-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-19 10:26:15" itemprop="dateModified" datetime="2021-06-19T10:26:15+08:00">2021-06-19</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>921</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="7-1-BITS"><a href="#7-1-BITS" class="headerlink" title="7.1 BITS"></a>7.1 BITS</h2><p>BITS指令告诉NASM生成的代码运行在16位模式、32位模式还是64位模式的处理器上。语法是<code>BITS XX</code>，其中<code>XX</code>是16、32或64。<br>在大多数情况下，不需要显式地使用<code>BITS</code>。设计用于32位或64位操作系统的<code>out</code>、<code>coff</code>、<code>elf*</code>、<code>macho</code>、<code>win32</code>和<code>win64</code>对象格式都会使NASM在默认情况下分别选择32位或64位模式。obj对象格式允许您指定定义为USE16或USE32的每个段，并且NASM将相应地设置其操作模式，因此也不需要使用BITS指令。<br>使用BITS指令最可能的原因是在一个平面二进制文件中写入32位或64位代码；这是因为bin输出格式默认为16位模式，以预期它最常用于写入DOS.COM网站程序，DOS系统设备驱动程序和引导加载程序软件。<br>BITS指令还可以用于为不同于输出格式的标准模式生成代码。<br>在16位DOS程序中使用32位指令并不需要仅指定32位；如果这样做，汇编程序将生成不正确的代码，因为它将编写针对32位平台的代码，以便在16位平台上运行。<br>当NASM处于位16模式时，使用32位数据的指令以0x66字节作为前缀，而引用32位地址的指令则以0x67作为前缀。在32位模式下，情况正好相反：32位指令不需要前缀，而使用16位数据的指令需要0x66，使用16位地址的指令需要0x67。<br>当NASM处于位64模式时，大多数指令的操作与位32相同模式。但是，还有8个通用寄存器和SSE寄存器，不再支持16位寻址。<br>默认地址大小为64位；可以使用0x67前缀选择32位寻址。但是，默认操作数大小仍然是32位，并且0x66前缀选择16位操作数大小。REX前缀用于选择64位操作数大小和访问新寄存器。必要时，NASM会自动插入REX前缀。<br>使用REX前缀时，处理器不知道如何寻址AH、BH、CH或DH（高8位传统）寄存器。相反，可以访问SP、BP SI和DI寄存器的低位8位，分别为SPL、BPL、SIL和DIL；但仅当使用REX前缀时。<br>BITS指令具有完全等效的基元形式，[位16]、[位32]和[位64]。用户级窗体是一个宏，它除了调用基元窗体之外没有其他功能。<br>请注意，空格是必需的，例如BITS32将不起作用！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/17/Note/%E7%AC%94%E8%AE%B0/Linux%E7%AC%94%E8%AE%B0/%E7%A3%81%E7%9B%98/Linux%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="朱辉">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhuhui's yard">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/17/Note/%E7%AC%94%E8%AE%B0/Linux%E7%AC%94%E8%AE%B0/%E7%A3%81%E7%9B%98/Linux%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-17 21:04:46" itemprop="dateCreated datePublished" datetime="2021-07-17T21:04:46+08:00">2021-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-19 10:26:15" itemprop="dateModified" datetime="2021-06-19T10:26:15+08:00">2021-06-19</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>757</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h3><p>磁盘在使用前必须进行分区,分区可在一定程度上提升数据安全性和系统性能.</p>
<p>当前磁盘有两种分区方式,MBR分区和GPT分区.</p>
<h4 id="MBR分区"><a href="#MBR分区" class="headerlink" title="MBR分区"></a>MBR分区</h4><h5 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h5><ul>
<li><p>MBR = Main Boot Record,主引导记录区,也称为MSDOS</p>
</li>
<li><p>采用MBR分区的磁盘,分区信息存储在0磁道\0柱面\1扇区上,共512字节数据,其存储分配如下图</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>MBR</td>
<td>446B</td>
<td>存储开机管理程序</td>
</tr>
<tr>
<td>DPT</td>
<td>64B</td>
<td>存储硬盘分区表</td>
</tr>
<tr>
<td>结束标志</td>
<td>2B</td>
<td>使用<code>55 AA</code>两个字节标志结束</td>
</tr>
</tbody></table>
<h5 id="DPT表结构"><a href="#DPT表结构" class="headerlink" title="DPT表结构"></a>DPT表结构</h5><ul>
<li><p>DPT = Disk Partition Table,硬盘分区表</p>
</li>
<li><p>分区表由4项组成,每项16个字节,每一项描述一个分区的基本信息.所以一个分区表最多只能表示4个分区.</p>
</li>
<li><p>16个字节含义如下</p>
<table>
<thead>
<tr>
<th>字节位</th>
<th>内容及含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>引导标志.若为80H表示活动分区,若为00H表示非活动分区。操作系统所在的分区即为活动分区</td>
</tr>
<tr>
<td>2、3、4</td>
<td>本分区的起始磁头号、扇区号、柱面号<br />磁头号——2<br />扇区号——3的低6位<br />柱面号——3的高2位+4的8位</td>
</tr>
<tr>
<td>5</td>
<td>分区类型符<br />00H——分区未使用<br />05H——扩展分区<br />06H——FAT16基本分区<br />07H——NTFS分区<br />0BH——FAT32基本分区<br />0FH——LBA模式扩展分区<br />83H——Linux分区</td>
</tr>
<tr>
<td>6、7、8</td>
<td>本分区的结束磁头号、扇区号、柱面号<br />磁头号——6<br />扇区号——7的低6位<br />柱面号——7的高2位+8的8位</td>
</tr>
<tr>
<td>9、10、11、12</td>
<td>逻辑起始扇区号，本分区已经使用的扇区数</td>
</tr>
<tr>
<td>13、14、15、16</td>
<td>本分区总扇区数</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h5 id="主分区和扩展分区"><a href="#主分区和扩展分区" class="headerlink" title="主分区和扩展分区"></a>主分区和扩展分区</h5><p>磁盘第一个扇区上的分区表称为分区表,可以将磁盘分为4个分区,分别为主分区和扩展分区.扩展分区最多只能有1个,也可以没有.</p>
<p>扩展分区内可以使用额外的扇区来记录分区信息,将扩展分区的扇区再次进行划分,划分出的分区称为逻辑分区.逻辑分区从属于扩展分区,可用存储范围为扩展分区的存储范围.</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zt_xcyk/article/details/53669383">MBR分区表详解</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/17/Note/%E7%AC%94%E8%AE%B0/Linux%E7%AC%94%E8%AE%B0/%E7%A3%81%E7%9B%98/Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="朱辉">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhuhui's yard">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/17/Note/%E7%AC%94%E8%AE%B0/Linux%E7%AC%94%E8%AE%B0/%E7%A3%81%E7%9B%98/Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-17 21:04:46" itemprop="dateCreated datePublished" datetime="2021-07-17T21:04:46+08:00">2021-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-24 17:57:11" itemprop="dateModified" datetime="2021-06-24T17:57:11+08:00">2021-06-24</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-Linux磁盘管理"><a href="#1-Linux磁盘管理" class="headerlink" title="1. Linux磁盘管理"></a>1. Linux磁盘管理</h1><hr>
<h2 id="1-1-基础知识"><a href="#1-1-基础知识" class="headerlink" title="1.1. 基础知识"></a>1.1. 基础知识</h2><ul>
<li>Linux磁盘管理的好坏直接关系到整个系统的性能</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/a1766855068/article/details/84942745?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159453639719725219960243%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=159453639719725219960243&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v3~pc_rank_v2-5-84942745.first_rank_ecpm_v3_pc_rank_v2&utm_term=Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86">磁盘基础知识</a></li>
</ul>
<hr>
<h2 id="1-2-磁盘分区"><a href="#1-2-磁盘分区" class="headerlink" title="1.2. 磁盘分区"></a>1.2. 磁盘分区</h2><h3 id="1-2-1-磁盘分区类型"><a href="#1-2-1-磁盘分区类型" class="headerlink" title="1.2.1. 磁盘分区类型"></a>1.2.1. 磁盘分区类型</h3><ul>
<li>见Linux磁盘分区</li>
</ul>
<h3 id="1-2-2-观察磁盘分区"><a href="#1-2-2-观察磁盘分区" class="headerlink" title="1.2.2. 观察磁盘分区"></a>1.2.2. 观察磁盘分区</h3><h4 id="lsblk命令"><a href="#lsblk命令" class="headerlink" title="lsblk命令"></a><code>lsblk</code>命令</h4><ul>
<li><p><code>list block</code></p>
</li>
<li><p>列出系统上所有的磁盘列表</p>
</li>
<li><p>常用参数</p>
<ul>
<li><p><code>-a</code>,显示所有设备,无参数时默认为<code>-a</code></p>
<p><img src="......%5C%E5%9B%BE%E7%89%87%5Cimage-20210526151411871.png" alt="image-20210526151411871"></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NAME</td>
<td>设备名称,默认省略/dev等前导目录</td>
</tr>
<tr>
<td>MAJ:MIN</td>
<td>主要:次要设备代码，系统用这两个代码识别设备</td>
</tr>
<tr>
<td>RM</td>
<td>是否为可卸载设备，<code>removable device</code></td>
</tr>
<tr>
<td>SIZE</td>
<td>设备容量</td>
</tr>
<tr>
<td>RO</td>
<td>是否为只读设备，<code>read only</code></td>
</tr>
<tr>
<td>TYPE</td>
<td>设备类型：<br /><code>loop</code>：使用文件模拟出的伪设备<br /><code>disk</code>：磁盘<br /><code>part</code>：分区<br /><code>rom</code>：只读存储器</td>
</tr>
<tr>
<td>MOUNTPOINT</td>
<td>设备挂载点</td>
</tr>
</tbody></table>
</li>
<li><p><code>-f</code>,显示文件系统信息</p>
<p><img src="......%5C%E5%9B%BE%E7%89%87%5Cimage-20210526151503304.png" alt="image-20210526151503304"></p>
</li>
</ul>
</li>
</ul>
<h4 id="blkid命令"><a href="#blkid命令" class="headerlink" title="blkid命令"></a><code>blkid</code>命令</h4><h3 id="1-2-3-创建磁盘分区"><a href="#1-2-3-创建磁盘分区" class="headerlink" title="1.2.3. 创建磁盘分区"></a>1.2.3. 创建磁盘分区</h3><h4 id="fdisk命令"><a href="#fdisk命令" class="headerlink" title="fdisk命令"></a><code>fdisk</code>命令</h4><ul>
<li>用于对采用<code>MBR(MSDOS)</code>磁盘分区格式的磁盘进行分区.</li>
</ul>
<h4 id="gdisk命令"><a href="#gdisk命令" class="headerlink" title="gdisk命令"></a><code>gdisk</code>命令</h4><ul>
<li>用于对采用<code>GPT</code>磁盘分区格式的磁盘进行分区.</li>
</ul>
<hr>
<h2 id="1-3-磁盘格式化-文件系统"><a href="#1-3-磁盘格式化-文件系统" class="headerlink" title="1.3. 磁盘格式化(文件系统)"></a>1.3. 磁盘格式化(文件系统)</h2><h3 id="1-3-1-创建文件系统"><a href="#1-3-1-创建文件系统" class="headerlink" title="1.3.1. 创建文件系统"></a>1.3.1. 创建文件系统</h3><ul>
<li><p><code>mkfs</code></p>
<ul>
<li><p><code>make file system</code>，进行磁盘文件系统的格式化</p>
</li>
<li><p>语法：<code>mkfs.name [选项] 格式化设备名</code>或者<code>mkfs [-t name] 格式化设备名</code></p>
</li>
<li><p><code>name</code>为目标文件系统的格式名称</p>
</li>
<li><p>使用<code>makfs[tab][tab]</code>可以查看支持的文件系统命令</p>
<p><img src="D:\Vnote\图片\image-20210513102243229.png" alt="image-20210513102243229"></p>
</li>
<li><p>示例</p>
<p><img src="D:\Vnote\图片\image-20210513102220710.png" alt="image-20210513102220710"></p>
</li>
</ul>
</li>
</ul>
<h3 id="1-3-2-检验文件系统"><a href="#1-3-2-检验文件系统" class="headerlink" title="1.3.2. 检验文件系统"></a>1.3.2. 检验文件系统</h3><h3 id="1-3-3-挂载文件系统"><a href="#1-3-3-挂载文件系统" class="headerlink" title="1.3.3. 挂载文件系统"></a>1.3.3. 挂载文件系统</h3><h2 id="1-4-常用命令"><a href="#1-4-常用命令" class="headerlink" title="1.4. 常用命令"></a>1.4. 常用命令</h2><ul>
<li><strong><code>df</code></strong><ul>
<li><code>disk free</code>，检查文件系统的磁盘空间占用状况，列出文件系统</li>
<li><strong>文件系统</strong>：是指操作系统用于明确存储硬盘设备或者分区上的文件的方法和数据结构，即为在存储设备上组织文件的方法。简单来说，规定用什么样的形式存放文件</li>
<li>语法：<code>df [选项] [目录或者文件名]</code></li>
<li>参数说明<ul>
<li>**<code>-a</code>**：列出所有文件系统，包括系统系统特有的<code>/proc</code>等文件系统</li>
<li>**<code>-k</code>**：以<code>KBytes</code>容量显示各文件系统</li>
<li>**<code>-m</code>**：以<code>MBytes</code>容量显示各文件系统</li>
<li>**<code>-h</code>**：以较容易阅读的<code>GB</code>、<code>MB</code>、<code>KB</code>等格式自行显示</li>
<li>**<code>-H</code>**：以<code>M=1000K</code>取代<code>M=1024K</code>的进位方式</li>
<li>**<code>-T</code>**：显示文件系统类型，连同该<code>partition</code>的<code>filesystem</code>名称也列出</li>
<li>**<code>-i</code>**：不用硬盘容量，而以<code>inode</code>的数量来显示</li>
</ul>
</li>
<li>实例<blockquote>
<p>列出所有文件系统<br><code>df</code>（默认将所有的文件系统以1K的容量显示出来）<br>  <img src="D:/Vnote/图片/34.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><strong><code>du</code></strong><ul>
<li><code>disk usage</code>，查看文件和目录的磁盘使用空间</li>
<li>语法：<code>du [选项] [目录或者文件名]</code></li>
<li>选项说明<ul>
<li>**<code>a</code>**：列出所有文件和目录的容量，默认仅统计目录下的文件夹的容量（包括隐藏文件夹）</li>
<li>**<code>h</code>**：以易读的容量单位显示</li>
<li>**<code>s</code>**：只列出总量</li>
<li>**<code>k</code>**：以<code>KByte</code>为单位进行显示</li>
<li>**<code>m</code>**：以<code>MByte</code>为单位进行显示</li>
</ul>
</li>
<li>实例<br>  <img src="D:/Vnote/图片/35.png"><br>  <code>.</code>表示总量</li>
</ul>
</li>
<li><strong><code>fdisk</code></strong><ul>
<li>用于显示磁盘分区信息</li>
<li>语法：<code>fdisk [-l] 装置名称</code></li>
<li>选项与参数<ul>
<li>**<code>-l</code>**：输出装置的所有分区内容，如果没有装置名称则默认为整个系统<h2 id="1-5-磁盘的挂载和删除"><a href="#1-5-磁盘的挂载和删除" class="headerlink" title="1.5. 磁盘的挂载和删除"></a>1.5. 磁盘的挂载和删除</h2></li>
</ul>
</li>
</ul>
</li>
<li><strong><code>mount</code></strong><ul>
<li>用于挂载磁盘，必须使用管理员权限运行</li>
<li>语法：<code>mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点</code></li>
</ul>
</li>
<li><strong><code>umount</code></strong><ul>
<li>用于卸载磁盘，必须使用管理员权限运行</li>
<li>语法：<code>umount [-fn] 装置文件名或者挂载点</code></li>
<li>选项与参数<ul>
<li>**<code>-f</code>**：强制卸除，在类似<code>NFS</code>无法读取到的情况下</li>
<li>**<code>-n</code>**：不升级<code>/etc/mtab</code>的情况下卸除</li>
</ul>
</li>
</ul>
</li>
<li><strong>在虚拟机上挂载U盘</strong><ul>
<li>插入U盘之后，运行命令<code>fdisk -l</code>观察命令运行的结果，查找与U盘相关的设备，一般为<code>/dev/sdb+数字</code></li>
<li>创建挂载位置，<code>/mnt</code>主要用于存放光盘软盘等可移动设备，所以在此目录下创建挂载U盘的文件夹，<code>mkdir /mnt/usb</code></li>
<li>使用<code>mount</code>命令挂载U盘（<code>fat16,fat32,ntfs都归为vfat格式</code>）</li>
<li>U使用完成后必须使用<code>umount</code>命令卸载</li>
</ul>
</li>
<li><strong>异常处理</strong><ul>
<li>解决卸载U盘时提示busy的问题<ul>
<li>执行命令<code>lsof |grep 挂载点</code>，或者<code>fuser -mv 挂载点</code></li>
<li>使用<code>kill</code>命令杀掉进程，<code>kill -9 xxxx(进程号，上一步bash后的数字)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-6-参考资料"><a href="#1-6-参考资料" class="headerlink" title="1.6. 参考资料"></a>1.6. 参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangcp-2014/p/5146343.html">Linux kill命令详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ccoran/article/details/84727034?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159454511619724845058577%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=159454511619724845058577&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v3~pc_rank_v2-2-84727034.first_rank_ecpm_v3_pc_rank_v2&utm_term=linux%E4%B8%AD%E7%9A%84%7C">Linux中&amp;和&amp;&amp;，|和||</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40797605/article/details/89075918?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159454514619195265901240%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=159454514619195265901240&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-89075918.first_rank_ecpm_v3_pc_rank_v2&utm_term=linux%E4%B8%AD%E7%9A%84%7Cgrep">Linux中grep命令详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/guoguo1980/article/details/2324454?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159454477319724839256033%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=159454477319724839256033&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-2324454.first_rank_ecpm_v3_pc_rank_v2&utm_term=linuxlsof">Linux lsof详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sky425509/article/details/84514776?ops_request_misc=&request_id=&biz_id=102&utm_term=linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8D%B8%E8%BD%BDu%E7%9B%98%E6%98%BE%E7%A4%BAbusy&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-84514776">解决卸载U盘问题</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/hehmxy/article/details/83351358?ops_request_misc=&request_id=&biz_id=102&utm_term=linux%E4%B8%AD%E7%9A%84%7Cgrep&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-83351358">Linux中grep命令的用法</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/17/Note/%E7%AC%94%E8%AE%B0/Linux%E7%AC%94%E8%AE%B0/%E7%A3%81%E7%9B%98/Linux%E7%A3%81%E7%9B%98%E7%BB%B4%E6%8A%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="朱辉">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhuhui's yard">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/17/Note/%E7%AC%94%E8%AE%B0/Linux%E7%AC%94%E8%AE%B0/%E7%A3%81%E7%9B%98/Linux%E7%A3%81%E7%9B%98%E7%BB%B4%E6%8A%A4/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-17 21:04:46" itemprop="dateCreated datePublished" datetime="2021-07-17T21:04:46+08:00">2021-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-19 10:26:15" itemprop="dateModified" datetime="2021-06-19T10:26:15+08:00">2021-06-19</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux磁盘维护"><a href="#Linux磁盘维护" class="headerlink" title="Linux磁盘维护"></a>Linux磁盘维护</h1><h2 id="dd命令"><a href="#dd命令" class="headerlink" title="dd命令"></a>dd命令</h2><blockquote>
<p>本文由 <a target="_blank" rel="noopener" href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-dd.html">www.runoob.com</a></p>
</blockquote>
<p>Linux dd 命令用于读取、转换并输出数据。</p>
<p>dd 可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。</p>
<p><strong>参数说明:</strong></p>
<ul>
<li>  if = 文件名：输入文件名，默认为标准输入。即指定源文件。</li>
<li>  of = 文件名：输出文件名，默认为标准输出。即指定目的文件。</li>
<li>ibs=bytes：一次读入 bytes 个字节，即指定一个块大小为 bytes 个字节。<br>  obs=bytes：一次输出 bytes 个字节，即指定一个块大小为 bytes 个字节。<br>  bs=bytes：同时设置读入 / 输出的块大小为 bytes 个字节。</li>
<li>  cbs=bytes：一次转换 bytes 个字节，即指定转换缓冲区大小。</li>
<li>  skip=blocks：从输入文件开头跳过 blocks 个块后再开始复制。</li>
<li>  seek=blocks：从输出文件开头跳过 blocks 个块后再开始复制。</li>
<li>  count=blocks：仅拷贝 blocks 个块，块大小等于 ibs 指定的字节数。</li>
<li>conv=&lt;关键字&gt;，关键字可以有以下 11 种：<ul>
<li>  conversion：用指定的参数转换文件。</li>
<li>  ascii：转换 ebcdic 为 ascii</li>
<li>  ebcdic：转换 ascii 为 ebcdic</li>
<li>  ibm：转换 ascii 为 alternate ebcdic</li>
<li>  block：把每一行转换为长度为 cbs，不足部分用空格填充</li>
<li>  unblock：使每一行的长度都为 cbs，不足部分用空格填充</li>
<li>  lcase：把大写字符转换为小写字符</li>
<li>  ucase：把小写字符转换为大写字符</li>
<li>  swap：交换输入的每对字节</li>
<li>  noerror：出错时不停止</li>
<li>  notrunc：不截短输出文件</li>
<li>  sync：将每个输入块填充到 ibs 个字节，不足部分用空（NUL）字符补齐。</li>
</ul>
</li>
<li>  –help：显示帮助信息</li>
<li>  –version：显示版本信息</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在 Linux 下制作启动盘，可使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=boot.img of=/dev/fd0 bs=1440k</span><br></pre></td></tr></table></figure>

<p>将 testfile 文件中的所有英文字母转换为大写，然后转成为 testfile_1 文件，在命令提示符中使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=testfile_2 of=testfile_1 conv=ucase</span><br></pre></td></tr></table></figure>

<p>其中 testfile_2 的内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat testfile_2 #testfile_2的内容  </span><br><span class="line">HELLO LINUX!  </span><br><span class="line">Linux is a free unix-type opterating system.  </span><br><span class="line">This is a linux testfile!  </span><br><span class="line">Linux test</span><br></pre></td></tr></table></figure>

<p>转换完成后，testfile_1 的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ dd if=testfile_2 of=testfile_1 conv=ucase #使用dd 命令，大小写转换记录了0+1 的读入  </span><br><span class="line">记录了0+1 的写出  </span><br><span class="line">95字节（95 B）已复制，0.000131446 秒，723 KB/s  </span><br><span class="line">cmd@hdd-desktop:~$ cat testfile_1 #查看转换后的testfile_1文件内容  </span><br><span class="line">HELLO LINUX!  </span><br><span class="line">LINUX IS A FREE UNIX-TYPE OPTERATING SYSTEM.  </span><br><span class="line">THIS IS A LINUX TESTFILE!  </span><br><span class="line">LINUX TEST #testfile_2中的所有字符都变成了大写字母</span><br></pre></td></tr></table></figure>

<p>由标准输入设备读入字符串，并将字符串转换成大写后，再输出到标准输出设备，使用的命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd conv=ucase</span><br></pre></td></tr></table></figure>

<p>输入以上命令后按回车键，输入字符串，再按回车键，按组合键 Ctrl+D 退出，出现以下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ dd conv=ucase </span><br><span class="line">Hello Linux! #输入字符串后按回车键  </span><br><span class="line">HELLO LINUX! #按组合键Ctrl+D退出，转换成大写结果  </span><br><span class="line">记录了0+1 的读入  </span><br><span class="line">记录了0+1 的写出  </span><br><span class="line">13字节（13 B）已复制，12.1558 秒，0.0 KB/s</span><br></pre></td></tr></table></figure>

<p> <a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-command-manual.html"><img src="https://www.runoob.com/images/up.gif"> Linux 命令大全</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/17/Note/%E7%AC%94%E8%AE%B0/Linux%E7%AC%94%E8%AE%B0/%E7%A3%81%E7%9B%98/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A1%AC%E7%9B%98%E6%89%A9%E5%AE%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="朱辉">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhuhui's yard">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/17/Note/%E7%AC%94%E8%AE%B0/Linux%E7%AC%94%E8%AE%B0/%E7%A3%81%E7%9B%98/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A1%AC%E7%9B%98%E6%89%A9%E5%AE%B9/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-17 21:04:46" itemprop="dateCreated datePublished" datetime="2021-07-17T21:04:46+08:00">2021-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-02 22:07:35" itemprop="dateModified" datetime="2021-07-02T22:07:35+08:00">2021-07-02</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>296</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>原来</p>
<p><img src="......%5C%E5%9B%BE%E7%89%87%5Cimage-20210526173306961.png" alt="image-20210526173306961"></p>
<p><img src="......%5C%E5%9B%BE%E7%89%87%5Cimage-20210526173317376.png" alt="image-20210526173317376"></p>
</li>
<li><p>删除sda2，并重新添加sda2和sda5</p>
<p><img src="......%5C%E5%9B%BE%E7%89%87%5Cimage-20210526173536992-1622021739182.png" alt="image-20210526173536992"></p>
<p><img src="......%5C%E5%9B%BE%E7%89%87%5Cimage-20210526173617028.png" alt="image-20210526173617028"></p>
</li>
</ul>
<p><img src="......%5C%E5%9B%BE%E7%89%87%5Cimage-20210526172349354.png" alt="image-20210526172349354"></p>
<p><img src="......%5C%E5%9B%BE%E7%89%87%5Cimage-20210526172417770.png" alt="image-20210526172417770"></p>
<p>保存重启</p>
<p><img src="......%5C%E5%9B%BE%E7%89%87%5Cimage-20210526173754852.png" alt="image-20210526173754852"></p>
<p><img src="......%5C%E5%9B%BE%E7%89%87%5Cimage-20210526172944395.png" alt="image-20210526172944395"></p>
<p><img src="......%5C%E5%9B%BE%E7%89%87%5Cimage-20210526173033362.png" alt="image-20210526173033362"></p>
<p><img src="......%5C%E5%9B%BE%E7%89%87%5Cimage-20210526173115813.png" alt="image-20210526173115813"></p>
<p><img src="......%5C%E5%9B%BE%E7%89%87%5Cimage-20210526173127161.png" alt="image-20210526173127161"></p>
<p><a target="_blank" rel="noopener" href="https://www.osyunwei.com/archives/9368.html">https://www.osyunwei.com/archives/9368.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.linuxprobe.com/linux-fdisk-size.html">https://www.linuxprobe.com/linux-fdisk-size.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dingchenxixi/article/details/50986472">https://blog.csdn.net/dingchenxixi/article/details/50986472</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9db2df60fd0a">https://www.jianshu.com/p/9db2df60fd0a</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/haojia/p/11951097.html">https://www.cnblogs.com/haojia/p/11951097.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.linuxcool.com/resize2fs">https://www.linuxcool.com/resize2fs</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/17/Note/%E7%AC%94%E8%AE%B0/Linux%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96%E8%AE%BE%E5%A4%87/%E5%B8%B8%E8%A7%81%E8%AE%BE%E5%A4%87%E5%8F%8A%E5%85%B6%E6%96%87%E4%BB%B6%E5%90%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="朱辉">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhuhui's yard">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/17/Note/%E7%AC%94%E8%AE%B0/Linux%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96%E8%AE%BE%E5%A4%87/%E5%B8%B8%E8%A7%81%E8%AE%BE%E5%A4%87%E5%8F%8A%E5%85%B6%E6%96%87%E4%BB%B6%E5%90%8D/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-17 21:04:46" itemprop="dateCreated datePublished" datetime="2021-07-17T21:04:46+08:00">2021-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-19 10:26:15" itemprop="dateModified" datetime="2021-06-19T10:26:15+08:00">2021-06-19</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>394</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="常见设备及其文件名"><a href="#常见设备及其文件名" class="headerlink" title="常见设备及其文件名"></a>常见设备及其文件名</h3><p>Linux系统中，所有设备都被当做文件来处理。设备文件一般存储在<code>/dev</code>目录内。</p>
<table>
<thead>
<tr>
<th>设备在Linux中的文件名</th>
<th>设备描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>/dev/sd[a-p]</code></td>
<td>SCSI/SATA/USB/SAS的硬盘,USB闪存盘</td>
</tr>
<tr>
<td><code>/dev/vd[a-p]</code></td>
<td>VirtI/O界面</td>
</tr>
<tr>
<td><code>/dev/fd[0-7]</code></td>
<td>软盘机</td>
</tr>
<tr>
<td><code>/dev/lp[0-2]</code></td>
<td>25针打印机</td>
</tr>
<tr>
<td><code>/dev/usb/lp[0-15]</code></td>
<td>USB接口打印机</td>
</tr>
<tr>
<td><code>/dev/input/mouse[0-15]</code></td>
<td>通用鼠标</td>
</tr>
<tr>
<td><code>/dev/pasux</code></td>
<td>PS/2界面鼠标</td>
</tr>
<tr>
<td><code>/dev/mouse</code></td>
<td>当前鼠标</td>
</tr>
<tr>
<td><code>/dev/scd[0-1]</code></td>
<td>通用CDROM/DVDROM</td>
</tr>
<tr>
<td><code>/dev/sr[0-1]</code></td>
<td>通用CDROM/DVDROM,常见于CentOS</td>
</tr>
<tr>
<td><code>/dev/cdrom</code></td>
<td>当前CDROM</td>
</tr>
<tr>
<td><code>/dev/ht0</code></td>
<td>IDE界面磁带机</td>
</tr>
<tr>
<td><code>/dev/st0</code></td>
<td>SATA/SCSI界面磁带机</td>
</tr>
<tr>
<td><code>/dev/tape</code></td>
<td>当前磁带</td>
</tr>
<tr>
<td><code>/dev/hd[a-d]</code></td>
<td>IDE硬盘(淘汰)</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/17/Note/%E7%AC%94%E8%AE%B0/Linux%E7%AC%94%E8%AE%B0/Linux%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/GNU-ld/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="朱辉">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhuhui's yard">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/17/Note/%E7%AC%94%E8%AE%B0/Linux%E7%AC%94%E8%AE%B0/Linux%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/GNU-ld/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-17 21:04:46" itemprop="dateCreated datePublished" datetime="2021-07-17T21:04:46+08:00">2021-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-19 10:26:15" itemprop="dateModified" datetime="2021-06-19T10:26:15+08:00">2021-06-19</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-GNU-ld"><a href="#1-GNU-ld" class="headerlink" title="1. GNU-ld"></a>1. GNU-ld</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1. 概述"></a>1.1. 概述</h2><p>ld工具使用ld链接脚本（以<code>lds</code>作为文件后缀）控制程序文件的链接过程，将多个目标文件<code>.o</code>和库文件<code>.a</code>链接成一个可执行文件。ld链接脚本主要作用是规定如何把输入文件中的段放入输出文件当中，并控制输出文件各个部分在程序地址空间内的布局。</p>
<blockquote>
<p>ld ld combines a number of object and archive files, relocates their data and ties up symbol references. Usually the last step in compiling a program is to run ld.</p>
</blockquote>
<h2 id="1-2-ld"><a href="#1-2-ld" class="headerlink" title="1.2. ld"></a>1.2. ld</h2><h2 id="1-3-ld链接脚本"><a href="#1-3-ld链接脚本" class="headerlink" title="1.3. ld链接脚本"></a>1.3. ld链接脚本</h2><h3 id="1-3-1-基本语法"><a href="#1-3-1-基本语法" class="headerlink" title="1.3.1. 基本语法"></a>1.3.1. 基本语法</h3><p>ld链接脚本由一系列的命令组成，每个命令是关键字加参数或者是对符号的赋值。命令使用<code>;</code>分割，脚本会忽略空格。注释风格和C语言相同。</p>
<h3 id="1-3-2-链接脚本的组成"><a href="#1-3-2-链接脚本的组成" class="headerlink" title="1.3.2. 链接脚本的组成"></a>1.3.2. 链接脚本的组成</h3><ul>
<li><p>链接配置（可有可无）<br>如一些符号变量的定义、入口地址、输出格式等</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STACK_SIZE = 0X200;</span><br><span class="line">OUTPUT_FORMAT(elf32-littlearm)</span><br><span class="line">OUTPUT_ARCH(arm)</span><br><span class="line">ENTRY(_start)</span><br></pre></td></tr></table></figure></li>
<li><p>内存布局定义<br>脚本中以<code>MEMORY</code>命令定义了存储空间，其中以<code>ORIGIN</code>定义地址空间的起始地址，<code>LENGTH</code>定义地址空间的长度。</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">FLASH (rx) : ORIGIN = 0, LENGTH = 64K</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>段链接定义<br>脚本中以<code>SECTIONS</code>命令定义一些段（<code>text、data、bss</code>等段）链接分布。</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    .text :</span><br><span class="line">    &#123;</span><br><span class="line">      *(.text*)</span><br><span class="line">    &#125; &gt; FLASH</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <code>.text</code>段即代码段，<code>*(.text*)</code>指示将工程中所有目标文件的<code>.text</code>段链接到<code>FLASH</code>中</p>
</li>
</ul>
<h3 id="1-3-3-常用变量、命令、关键字"><a href="#1-3-3-常用变量、命令、关键字" class="headerlink" title="1.3.3. 常用变量、命令、关键字"></a>1.3.3. 常用变量、命令、关键字</h3><h4 id="1-3-3-1-MEMORY-命令"><a href="#1-3-3-1-MEMORY-命令" class="headerlink" title="1.3.3.1. MEMORY 命令"></a>1.3.3.1. MEMORY 命令</h4><p>使用<code>MEMORY</code>来定义内存如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MEMORY &#123;</span><br><span class="line">NAME1 [(ATTR)] : ORIGIN = ORIGIN1, LENGTH = LEN2</span><br><span class="line">NAME2 [(ATTR)] : ORIGIN = ORIGIN2, LENGTH = LEN2</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>NAME ：存储区域的名字。（自己可以随意命名）</li>
<li>ATTR ：定义该存储区域的属性。ATTR 属性内可以出现以下 7 个字符：<ul>
<li><code>R</code>只读<code>section</code></li>
<li><code>W</code>读/写<code>section</code></li>
<li><code>X</code>可执行<code>section</code></li>
<li><code>A</code>可分配的<code>section</code></li>
<li><code>I</code>初始化了的<code>section</code></li>
<li><code>L</code>同<code>I</code></li>
<li><code>!</code>不满足该字符之后的任何一个属性的<code>section</code></li>
</ul>
</li>
<li>ORIGIN ：关键字，区域的开始地址，可简写成 org 或 o</li>
<li>LENGTH ：关键字，区域的大小，可简写成 len 或 l<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">rom (rx) : ORIGIN = 0, LENGTH = 256K</span><br><span class="line">ram (!rx) : org = 0×40000000, l = 4M</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-3-3-2-定位符-的使用"><a href="#1-3-3-2-定位符-的使用" class="headerlink" title="1.3.3.2. 定位符.的使用"></a>1.3.3.2. 定位符<code>.</code>的使用</h4><p><code>.</code>表示当前地址，它可以被赋值也可以赋值给某个变量。如下为将当前地址赋值给某个变量（链接器链接是按照 SECTIONS 里的段顺序排列的，前面的排列完之后就能计算出当前地址）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAM_START = .;</span><br></pre></td></tr></table></figure>
<p>如下为将段存放在特定的地址中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = 0×10000;            //将当前地址设置为0x10000，即为将目标文件的text段从0x10000开始存放</span><br><span class="line">    .text :</span><br><span class="line">    &#123;</span><br><span class="line">        *(.text)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = 0×8000000;</span><br><span class="line">    .data :</span><br><span class="line">    &#123;</span><br><span class="line">        *(.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-3-3-SECTIONS-命令"><a href="#1-3-3-3-SECTIONS-命令" class="headerlink" title="1.3.3.3. SECTIONS 命令"></a>1.3.3.3. SECTIONS 命令</h4><p>SECTIONS 基本的命令语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">       ...</span><br><span class="line">      secname start BLOCK(align) (NOLOAD) : AT ( ldadr )</span><br><span class="line">      &#123;</span><br><span class="line">        contents</span><br><span class="line">      &#125; &gt;region :phdr =fill</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么多参数中，只有 secname 和 contents 是必须的，即可简写成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">       ...</span><br><span class="line">      secname :</span><br><span class="line">      &#123;</span><br><span class="line">        contents</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链接脚本本质就是描述输入和输出。<code>secname</code>表示输出文件的段，即输出文件中有哪些段。而<code>contents</code>就是描述输出文件的这个段从哪些输入文件里抽取而来。<br>如下，将目标文件的数据段存放在输出文件的数据段（段名自己定义, 段名前后必须要有空格）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">       ...</span><br><span class="line">      .data :</span><br><span class="line">      &#123;</span><br><span class="line">        main.o（.data）</span><br><span class="line">        *(.data)</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>*(.data)</code>表示将所有的目标的<code>.data</code>段链接到输出文件<code>.data</code>段中，特别注意的是，之前链接过的就不会再链接，这样做的目的是可以将某些特殊的目标文件链接到地址前面。</p>
<p>其他参数</p>
<ul>
<li>start ：表示将某个段强制链接到的地址。</li>
<li>AT（addr）：实现存放地址和加载地址不一致的功能，AT 表示在文件中存放的位置，而在内存里呢，按照普通方式存储。</li>
<li>region：这个 region 就是前面说的 MEMORY 命令定义的位置信息。</li>
</ul>
<h4 id="1-3-3-4-PROVIDE-关键字"><a href="#1-3-3-4-PROVIDE-关键字" class="headerlink" title="1.3.3.4. PROVIDE 关键字"></a>1.3.3.4. PROVIDE 关键字</h4><p>该关键字定义一个（目标文件内被引用但没定义）符号。相当于定义一个全局变量，其他C文件可以引用它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    .text :</span><br><span class="line">    &#123;</span><br><span class="line">        *(.text)</span><br><span class="line">        _etext = .;</span><br><span class="line">        PROVIDE(etext = .);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，目标文件可以引用<code>etext</code>符号，其地址为定义为<code>.text section</code>之后的第一个字节的地址。C文件中引用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main（）</span><br><span class="line">&#123;</span><br><span class="line">    //引用该变量</span><br><span class="line">    extern char  _etext;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-3-5-KEEP-关键字"><a href="#1-3-3-5-KEEP-关键字" class="headerlink" title="1.3.3.5. KEEP 关键字"></a>1.3.3.5. KEEP 关键字</h4><p>在连接命令行内使用了选项–gc-sections 后，连接器可能将某些它认为没用的 section 过滤掉，此时就有必要强制连接器保留一些特定的 section，可用 KEEP() 关键字达此目的。如 KEEP(* (.text)) 或 KEEP(SORT(*)(.text))</p>
<h3 id="1-3-4-简单示例"><a href="#1-3-4-简单示例" class="headerlink" title="1.3.4. 简单示例"></a>1.3.4. 简单示例</h3><p>下面以 KL26 芯片的链接脚本作为一个简单的示例，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * In this linker script there is no heap available.</span><br><span class="line"> * The stack start at the end of the ram segment.</span><br><span class="line"> */</span><br><span class="line">STACK_SIZE = 0x2000;             /*  stack size config   8k        */</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Take a look in the &quot;The GNU linker&quot; manual, here you get</span><br><span class="line"> * the following information about the &quot;MEMORY&quot;:</span><br><span class="line"> *</span><br><span class="line"> * &quot;The MEMORY command describes the location and size of </span><br><span class="line"> * blocks of memory in the target.&quot;</span><br><span class="line"> */</span><br><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">   FLASH_INT     (rx)  : ORIGIN = 0x00000000, LENGTH = 0x00000100</span><br><span class="line">   FLASH_CONFIG  (rx)  : ORIGIN = 0x00000400, LENGTH = 0x00000010</span><br><span class="line">   FLASH_TEXT    (rx)  : ORIGIN = 0x00000410, LENGTH = 0x0001F7F0</span><br><span class="line">   RAM           (rwx) : ORIGIN = 0x1FFFF000, LENGTH = 16K</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * And the &quot;SECTION&quot; is used for:</span><br><span class="line"> *</span><br><span class="line"> * &quot;The SECTIONS command tells the linker how to map input</span><br><span class="line"> * sections into output sections, and how to place the output</span><br><span class="line"> * sections in memory.</span><br><span class="line"> */</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">   /* The startup code goes first into internal flash */</span><br><span class="line">    .interrupts :</span><br><span class="line">    &#123;</span><br><span class="line">      __VECTOR_TABLE = .;</span><br><span class="line">      . = ALIGN(4);</span><br><span class="line">      KEEP(*(.vectors))         /* Startup code */</span><br><span class="line">      . = ALIGN(4);</span><br><span class="line">    &#125; &gt; FLASH_INT</span><br><span class="line"></span><br><span class="line">    .flash_config :</span><br><span class="line">    &#123;</span><br><span class="line">      . = ALIGN(4);</span><br><span class="line">      KEEP(*(.FlashConfig))    /* Flash Configuration Field (FCF) */</span><br><span class="line">      . = ALIGN(4);</span><br><span class="line">    &#125; &gt; FLASH_CONFIG</span><br><span class="line"></span><br><span class="line">     .text :</span><br><span class="line">    &#123;</span><br><span class="line">        _stext = .;           /* Provide the name for the start of this section */</span><br><span class="line">  </span><br><span class="line">        *(.text)</span><br><span class="line">        *(.text.*)              /*  cpp namespace function      */</span><br><span class="line">        *(.romrun)              /*  rom中必须的函数             */</span><br><span class="line">        </span><br><span class="line">        . = ALIGN(4);           /* Align the start of the rodata part */</span><br><span class="line">        *(.rodata)              /*  read-only data (constants)  */</span><br><span class="line">        *(.rodata*)</span><br><span class="line">        *(.glue_7)</span><br><span class="line">        *(.glue_7t)</span><br><span class="line">    &#125; &gt; FLASH_TEXT</span><br><span class="line"></span><br><span class="line">    /* section information for simple shell symbols */</span><br><span class="line">    .text :</span><br><span class="line">    &#123;</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        __shellsym_tab_start = .;</span><br><span class="line">        KEEP(*(.shellsymbol))</span><br><span class="line">        __shellsym_tab_end = .;</span><br><span class="line">    &#125; &gt;FLASH_TEXT</span><br><span class="line"></span><br><span class="line">    /* .ARM.exidx is sorted, so has to go in its own output section */</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">     __exidx_start = .;</span><br><span class="line">     PROVIDE(__exidx_start = __exidx_start);</span><br><span class="line">    .ARM.exidx :</span><br><span class="line">    &#123;</span><br><span class="line">        /* __exidx_start = .; */</span><br><span class="line">        *(.ARM.exidx* .gnu.linkonce.armexidx.*)</span><br><span class="line">        /* __exidx_end = .;   */</span><br><span class="line">    &#125; &gt; FLASH_TEXT</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">     __exidx_end = .;</span><br><span class="line">     PROVIDE(__exidx_end = __exidx_end);</span><br><span class="line"></span><br><span class="line">    /* .data 段数据初始化内容放在这里 */</span><br><span class="line">    . = ALIGN(16);</span><br><span class="line">    _etext = . ;</span><br><span class="line">    PROVIDE (etext = .);</span><br><span class="line">    </span><br><span class="line">   /*</span><br><span class="line">    * The &quot;.data&quot; section is used for initialized data</span><br><span class="line">    * and for functions (.fastrun) which should be copied </span><br><span class="line">    * from flash to ram. This functions will later be</span><br><span class="line">    * executed from ram instead of flash.</span><br><span class="line">    */</span><br><span class="line">   .data : AT (_etext)</span><br><span class="line">   &#123;</span><br><span class="line">      . = ALIGN(4);        /* Align the start of the section */</span><br><span class="line">      _sdata = .;          /* Provide the name for the start of this section */</span><br><span class="line">      </span><br><span class="line">      *(.data)</span><br><span class="line">      *(.data.*)</span><br><span class="line">      </span><br><span class="line">      . = ALIGN(4);        /* Align the start of the fastrun part */</span><br><span class="line">      *(.fastrun)</span><br><span class="line">      *(.fastrun.*)</span><br><span class="line">      </span><br><span class="line">      . = ALIGN(4);        /* Align the end of the section */</span><br><span class="line">   &#125; &gt; </span><br><span class="line">   </span><br><span class="line">   _edata = .;             /* Provide the name for the end of this section */</span><br><span class="line">   </span><br><span class="line">   USB_RAM_GAP = DEFINED(__usb_ram_size__) ? __usb_ram_size__ : 0x800;</span><br><span class="line">   /*</span><br><span class="line">    * The &quot;.bss&quot; section is used for uninitialized data.</span><br><span class="line">    * This section will be cleared by the startup code.</span><br><span class="line">    */</span><br><span class="line">   .bss :</span><br><span class="line">   &#123;</span><br><span class="line">      . = ALIGN(4);        /* Align the start of the section */</span><br><span class="line">      _sbss = .;           /* Provide the name for the start of this section */</span><br><span class="line">      </span><br><span class="line">      *(.bss)</span><br><span class="line">      *(.bss.*)</span><br><span class="line">      . = ALIGN(512);</span><br><span class="line">      USB_RAM_START = .;</span><br><span class="line">    . += USB_RAM_GAP;</span><br><span class="line">      </span><br><span class="line">      . = ALIGN(4);        /* Align the end of the section */</span><br><span class="line">   &#125; &gt; RAM</span><br><span class="line">   _ebss = .;              /* Provide the name for the end of this section */</span><br><span class="line">   </span><br><span class="line">    /* 系统堆 */</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    PROVIDE (__heap_start__ = .);</span><br><span class="line">    .heap (NOLOAD) :</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125; &gt; RAM</span><br><span class="line">    . = ORIGIN(RAM) + LENGTH(RAM) - STACK_SIZE;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    PROVIDE (__heap_end__ = .);</span><br><span class="line">   </span><br><span class="line">   /* </span><br><span class="line">    * The &quot;.stack&quot; section is our stack.</span><br><span class="line">    * Here this section starts at the end of the ram segment.</span><br><span class="line">    */</span><br><span class="line">   _estack = ORIGIN(RAM) + LENGTH(RAM);</span><br><span class="line"></span><br><span class="line">   m_usb_bdt USB_RAM_START (NOLOAD) :</span><br><span class="line">   &#123;</span><br><span class="line">     *(m_usb_bdt)</span><br><span class="line">     USB_RAM_BDT_END = .;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   m_usb_global USB_RAM_BDT_END (NOLOAD) :</span><br><span class="line">   &#123;</span><br><span class="line">     *(m_usb_global)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*** EOF **/</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="朱辉"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">朱辉</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">129</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021-7-16 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朱辉</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">286k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:20</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
