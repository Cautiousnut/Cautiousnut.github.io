<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cautiousnut.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="C函数知识点总结，主要参考Cprimer第6章内容">
<meta property="og:type" content="article">
<meta property="og:title" content="C++类">
<meta property="og:url" content="https://cautiousnut.github.io/2022/08/31/C++%E7%B1%BB/index.html">
<meta property="og:site_name" content="静水流深">
<meta property="og:description" content="C函数知识点总结，主要参考Cprimer第6章内容">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.staticaly.com/gh/ZhuHuixj/Image@main/img/image-20220824163710700.png">
<meta property="article:published_time" content="2022-08-31T14:29:00.000Z">
<meta property="article:modified_time" content="2022-09-07T14:11:41.180Z">
<meta property="article:author" content="StillWater">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.staticaly.com/gh/ZhuHuixj/Image@main/img/image-20220824163710700.png">

<link rel="canonical" href="https://cautiousnut.github.io/2022/08/31/C++%E7%B1%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++类 | 静水流深</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">静水流深</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cautiousnut.github.io/2022/08/31/C++%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="StillWater">
      <meta itemprop="description" content="业精于勤荒于嬉，行成于思毁于随">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++类
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-31 22:29:00" itemprop="dateCreated datePublished" datetime="2022-08-31T22:29:00+08:00">2022-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-07 22:11:41" itemprop="dateModified" datetime="2022-09-07T22:11:41+08:00">2022-09-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h2>
<h3 id="1-类的特性"><a class="markdownIt-Anchor" href="#1-类的特性"></a> 1. 类的特性</h3>
<h4 id="11-类类型"><a class="markdownIt-Anchor" href="#11-类类型"></a> 1.1 类类型</h4>
<h5 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h5>
<p>每个类定义了唯一的类型，跟他们的内部成员没有关系。</p>
<p>可以把类名作为类型的名称使用，直接指向类类型；也可以将类名跟在关键字<code>class</code>或<code>struct</code>后面</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">A item1;					<span class="comment">//默认初始化A类型的对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> item1;				<span class="comment">//等价的声明</span></span><br></pre></td></tr></table></figure>
<h5 id="类的声明"><a class="markdownIt-Anchor" href="#类的声明"></a> 类的声明</h5>
<p>类可以声明但不定义，这种声明有时也成为<mark>前向声明</mark>。类声明向程序中引入了类名字并且指明它是一种类类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br></pre></td></tr></table></figure>
<p>声明之后定义之前的类类型是<mark>不完全类型</mark>，因为不知道它所包含的成员</p>
<p>不完全类型只能用于以下情况</p>
<ul>
<li>定义指向这种类型的指针或引用</li>
<li>声明（但不能定义）以不完全类型为参数或者返回类型的函数</li>
<li>静态成员</li>
</ul>
<h4 id="12-this指针"><a class="markdownIt-Anchor" href="#12-this指针"></a> 1.2 this指针</h4>
<h5 id="基本原理"><a class="markdownIt-Anchor" href="#基本原理"></a> 基本原理</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A obj;</span><br><span class="line">    obj.<span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述例子中，对象<code>obj</code>调用<code>test</code>函数。当我们调用成员函数时，实际上实在替相应的对象调用它。上述调用中，<code>test</code>函数返回<code>a</code>变量时，实际上返回的是<code>obj.a</code>。</p>
<p>成员函数通过一个名为<code>this</code>的隐式的参数来获取调用它的对象，当使用对象调用成员函数时，会用该对象的地址初始化<code>this</code>指针，并在类内部隐式的使用<code>this</code>指针访问类内成员</p>
<p><code>this</code>形参是隐式定义的，并且是一个常量指针（指针本身是常量）。可以按照如下方式理解<code>this</code>及函数调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A*<span class="type">const</span> <span class="keyword">this</span>;					<span class="comment">//A类对应的this指针，常量指针</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A::test</span><span class="params">(A*<span class="type">const</span> <span class="keyword">this</span>)</span></span>&#123;		<span class="comment">//test函数声明和定义的等价形式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;a;	</span><br><span class="line">&#125;</span><br><span class="line">A::<span class="built_in">test</span>(&amp;obj);					<span class="comment">//obj.test()，函数调用的等价形式</span></span><br></pre></td></tr></table></figure>
<h5 id="const成员函数"><a class="markdownIt-Anchor" href="#const成员函数"></a> const成员函数</h5>
<p>默认情况下<code>this</code>为常量指针，没有底层<code>const</code>资格，因此不能把<code>this</code>绑定到一个常量对象上（具有底层<code>const</code>资格），这使得常量对象无法调用对应类中的成员函数。此时便可以使用<code>const</code>成员函数</p>
<p><code>const</code>成员函数可以将<code>this</code>指针的隐式定义从原来的<code>A*const this</code>修改为<code>const A*const this</code>，即为将<code>this</code>声明为常量指针和常量指针。当成员函数内不改变<code>this</code>所指向的对象时，就可以使用<code>const</code>成员函数</p>
<p><code>const</code>成员函数的格式即为将<code>const</code>放置在函数的参数列表之后，<code>const</code>成员函数又称为常量成员函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">t1</span><span class="params">()</span> <span class="type">const</span></span>&#123;			<span class="comment">//此时，函数无法对对象进行修改</span></span><br><span class="line">        <span class="keyword">return</span> a;			<span class="comment">//this的类型为const A*const this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">t2</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A::t2</span><span class="params">()</span> <span class="type">const</span></span>&#123;			<span class="comment">//声明和定义时都必须有const</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="返回this的函数"><a class="markdownIt-Anchor" href="#返回this的函数"></a> 返回this的函数</h5>
<p>成员函数可以以引用或者指针的形式返回<code>this</code>所指的对象或者<code>this</code>本身</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回引用</span></span><br><span class="line"><span class="function">A&amp; <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回指针</span></span><br><span class="line"><span class="function">A* <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13-成员函数和内联函数"><a class="markdownIt-Anchor" href="#13-成员函数和内联函数"></a> 1.3 成员函数和内联函数</h4>
<p>定义在类内的成员函数是自动<code>inline</code>的（注意是定义，不是声明）</p>
<p>可以显式的在类的<strong>内部</strong>使用<code>inline</code>修饰函数声明或者在类的<strong>外部</strong>使用<code>inline</code>修饰函数定义来将成员函数显式的设置为内联函数，当然也可以同时。最好在函数定义处说明<code>inline</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">t1</span><span class="params">()</span></span>&#123;					<span class="comment">//类内inline</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">t2</span><span class="params">()</span></span>;					<span class="comment">//类外inline</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">t3</span><span class="params">()</span></span>;					<span class="comment">//内外都有inline</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A::t2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">A::t3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>inline</code>成员函数必须与相应的类定义在同一个头文件中，因为要进行展开</p>
<h4 id="14-可变数据成员"><a class="markdownIt-Anchor" href="#14-可变数据成员"></a> 1.4 可变数据成员</h4>
<p>在<mark>任何情况</mark>下都可修改的类数据成员，永远不会是<code>const</code>，即使是在<code>const</code>成员函数、<code>const</code>对象等情况下。</p>
<p>使用<code>mutable</code>关键字将数据成员声明为可变数据成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::modify</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    ++a;								<span class="comment">//a是可修改的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15-类内初始值"><a class="markdownIt-Anchor" href="#15-类内初始值"></a> 1.5 类内初始值</h4>
<p><code>C++11</code>标准规定，可以为类内数据成员提供一个<strong>类内初始值</strong>，用于初始化</p>
<p>类内初始值或者放在<strong>花括号里</strong>，或者放在<strong>等号右边</strong>，不能使用圆括号</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a&#123;<span class="number">1</span>&#125;;							<span class="comment">//列表初始化，直接初始化</span></span><br><span class="line">    <span class="type">int</span> b = &#123;<span class="number">1</span>&#125;;						<span class="comment">//列表初始化，拷贝初始化</span></span><br><span class="line">    <span class="type">int</span> c = <span class="number">1</span>;							<span class="comment">//等号右边，拷贝初始化</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">d</span><span class="params">(<span class="number">1</span>)</span></span>;							<span class="comment">//报错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="2-特殊成员函数"><a class="markdownIt-Anchor" href="#2-特殊成员函数"></a> 2. 特殊成员函数</h3>
<h4 id="21-构造函数"><a class="markdownIt-Anchor" href="#21-构造函数"></a> 2.1 构造函数</h4>
<p>构造函数用于类对象的初始化，在对象被创建时会自动被调用执行。必须是<code>public</code>访问权限</p>
<p>构造函数具有以下基本特点</p>
<ul>
<li>函数名和类名相同</li>
<li>没有返回类型和返回值</li>
<li>一个类可以包含多个构造函数，类似普通函数的重载</li>
<li>不能被声明为<code>const</code>成员函数，因为对象构造过程中可修改</li>
</ul>
<h5 id="默认构造函数"><a class="markdownIt-Anchor" href="#默认构造函数"></a> 默认构造函数</h5>
<p>没有任何参数或者所有参数都有默认值的构造函数称为<mark>默认构造函数</mark>，默认构造函数用于控制类的默认初始化过程</p>
<p>编译器会为没有显式定义构造函数的类隐式的定义一个<mark>默认构造函数</mark>，称为<mark>合成的默认构造函数</mark></p>
<p>合成的默认构造函数按照如下规则初始化类数据成员</p>
<ul>
<li>如果类内定义数据成员时给出了初始值，则使用此初始值进行初始化</li>
<li>否则，对该成员执行默认初始化</li>
</ul>
<p>默认构造函数（包括初始值列表）中没有初始化的成员也按照<strong>上述方式进行初始化</strong></p>
<p><strong>注意</strong></p>
<ul>
<li>
<p>类中必须有一个默认构造函数（包括合成的默认构造函数）</p>
</li>
<li>
<p>只有类没有声明任何构造函数时，编译器才会自动生成默认构造函数</p>
</li>
<li>
<p>含有内置类型或者复合类型成员的类应该在类的内部初始化这些成员（类内初始值）或者自定义构造函数。因为此时合成的默认构造函数如果使用默认初始化会导致这些成员的值未定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A obj;</span><br><span class="line">    obj.<span class="built_in">print</span>();					</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.staticaly.com/gh/ZhuHuixj/Image@main/img/image-20220824163710700.png" alt="image-20220824163710700" /></p>
</li>
<li>
<p>当类内包含其他类类型的成员时，无法生成默认的构造函数，此时必须显式提供构造函数</p>
</li>
</ul>
<h5 id="默认构造函数的作用"><a class="markdownIt-Anchor" href="#默认构造函数的作用"></a> 默认构造函数的作用</h5>
<p>默认构造函数在对象被<strong>默认初始化</strong>和<strong>值初始化</strong>时被自动执行</p>
<p><mark>默认初始化</mark>的发生情况</p>
<ul>
<li>
<p>块作用域内定义非静态变量和数组时没有给出初始值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line">A item1;				<span class="comment">//调用A的默认构造函数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类本身含有类类型成员且使用合成的默认构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">  A item1;  			<span class="comment">//B使用合成的默认构造函数时会调用A的默认构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类类型成员没有在构造函数初始值列表中显式的初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    A item1;</span><br><span class="line">    <span class="built_in">B</span>()&#123;&#125;				<span class="comment">//B调用构造函数时会调用A的默认构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><mark>值初始化</mark>的发生情况</p>
<ul>
<li>
<p>数组初始化的过程中提供的初始值少于数组的大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;默认构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a[<span class="number">2</span>] = &#123;&#125;;		<span class="comment">//执行两次默认构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不使用初始值定义局部静态变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num;		<span class="comment">//num=0，内置类型值初始化为0</span></span><br><span class="line">    <span class="keyword">return</span> ++num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;默认构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> A a;			<span class="comment">//调用默认构造函数进行初始化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>书写形如<code>T()</code>的表达式显式的请求值初始化（容器初始化只提供数量而没有提供初始值？）</p>
</li>
</ul>
<h5 id="构造函数初始值列表"><a class="markdownIt-Anchor" href="#构造函数初始值列表"></a> 构造函数初始值列表</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类内</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;  </span><br><span class="line">    <span class="type">int</span> b[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> &amp;c;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> num):<span class="built_in">a</span>(<span class="number">1</span>),b&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,<span class="built_in">c</span>(num)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;  </span><br><span class="line">    <span class="type">int</span> b[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> &amp;c;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> num);</span><br><span class="line">&#125;;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> num):<span class="built_in">a</span>(<span class="number">1</span>),b&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,<span class="built_in">c</span>(num)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>使用冒号开始构造函数初始值列表，每个名字后紧跟括号括起来的(或者花括号)成员初始值，不同成员的初始化通过逗号分隔开</p>
<h5 id="初始化和赋值"><a class="markdownIt-Anchor" href="#初始化和赋值"></a> 初始化和赋值</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">1.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">a</span>(<span class="number">1</span>),<span class="built_in">b</span>(<span class="number">1.0</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述两种方式都为变量的初始化操作，下面这种为变量的赋值操作。构造函数体执行之前会对没有进行初始化（没有在定义时初始化也没有在构造函数初始值列表中初始化）的成员执行<strong>默认初始化操作</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        b = <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>即类内定义变量时给出初始值和使用构造函数初始值列表都是进行初始化，而在构造函数函数体中的操作则为赋值</p>
<p>对于const类型、引用类型和未提供默认构造函数的类类型等，初始化和赋值必须严格区分，否则会引发错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span>&amp;b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> c)&#123;					<span class="comment">//错误，无法进行赋值操作</span></span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> c):<span class="built_in">a</span>(<span class="number">1</span>),<span class="built_in">b</span>(c)&#123;&#125;		<span class="comment">//正确，进行初始化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="成员初始化顺序"><a class="markdownIt-Anchor" href="#成员初始化顺序"></a> 成员初始化顺序</h5>
<p>构造函数初始值列表的优先级高于定义时初始化，如果一个变量在初始值列表和定义时进行了初始化，则以初始值列表为准</p>
<p>构造函数初始值列表只说明初始化成员的值，而不影响初始化的顺序。成员的初始化顺序由其在类中定义的顺序决定，先定义的先被初始化，以此类推</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="comment">//此语句会出错</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> c):<span class="built_in">b</span>(c),<span class="built_in">a</span>(b)&#123;&#125;			<span class="comment">//先初始化a，再初始化b</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="委托构造函数"><a class="markdownIt-Anchor" href="#委托构造函数"></a> 委托构造函数</h5>
<p>构造函数可以使用同一类中的其他构造函数执行自己的初始化过程，即把它自己的一些职责委托给了其他构造函数。这种构造函数即为<strong>委托构造函数</strong></p>
<p>委托构造函数的语法类似构造函数初始值列表，在函数参数列表之后使用<code>:</code>后接想要委托的构造函数，其后再接函数体。委托构造函数会在函数体执行之前执行受委托的构造函数，然后再执行自己的函数体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">a</span>(a),<span class="built_in">b</span>(b)&#123;&#125;		<span class="comment">//构造函数1</span></span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">A</span>(<span class="number">1</span>,<span class="number">2</span>)&#123;&#125;					<span class="comment">//委托构造函数1进行初始化</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> c):<span class="built_in">A</span>()&#123;&#125;					<span class="comment">//委托默认构造函数进行初始化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="隐式的类类型转换"><a class="markdownIt-Anchor" href="#隐式的类类型转换"></a> 隐式的类类型转换</h5>
<p>如果类的构造函数只接受一个实参，则实际上定义了一个从实参类型转换为此类类型的转换机制，此机制就自动调用此构造函数完成。</p>
<p>隐式类类型转换的触发<strong>条件</strong>为</p>
<ul>
<li>类含有只接收一个实参（假设为<code>T</code>类型）的构造函数（必须接收一个实参，可以有其他默认实参）</li>
<li>在需要使用类类型变量的地方，直接使用<code>T</code>类型变量替代</li>
<li>只能进行一步转换，即必须是<code>T</code>类型，而不能是其他可以转换为<code>T</code>类型的类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;默认构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n):<span class="built_in">num</span>(n)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">const</span> A&amp;a)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; a.num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;					<span class="comment">//调用默认构造函数进行初始化</span></span><br><span class="line">    a.<span class="built_in">test</span>(<span class="number">1</span>);				<span class="comment">//int类型转换为A类型，调用A(int)构造函数获取临时A对象传入test</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*执行结果</span></span><br><span class="line"><span class="comment">*	默认构造函数</span></span><br><span class="line"><span class="comment">*	构造函数</span></span><br><span class="line"><span class="comment">*	1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>进行隐式类类型转换时，编译器自动调用相应的构造函数创建临时的类类型对象传入当前语句或函数。当前语句或函数使用完成后，临时对象会被销毁</p>
<p>可以通过将构造函数声明为<code>explicit</code>来阻止隐式的类类型转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;默认构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> b = <span class="number">1</span>)</span>:num(n)&#123;</span>	<span class="comment">//阻止隐式的类类型转换</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">const</span> A&amp;a)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; a.num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.<span class="built_in">test</span>(<span class="number">1</span>);					<span class="comment">//此时会报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>explicit</code>关键字只对接收一个实参（除默认实参外）的构造函数有用，并且只能用于类内的构造函数声明中，在类外的构造函数定义时不能使用</p>
<p>使用<code>explicit</code>关键字修饰的构造函数只能用于直接初始化，不能用于拷贝形式的初始化过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用上一代码中的定义</span></span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;						<span class="comment">//正确，直接初始化</span></span><br><span class="line">A a = <span class="number">1</span>;					<span class="comment">//错误，拷贝初始化</span></span><br></pre></td></tr></table></figure>
<p>使用<code>explicit</code>关键字修饰的构造函数不会被用于隐式的类型转换过程，但是还是可以显式的调用来强制转换类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">a.<span class="built_in">test</span>(<span class="built_in">A</span>(<span class="number">1</span>));				<span class="comment">//正确，显式转换</span></span><br><span class="line">a.<span class="built_in">test</span>(<span class="built_in">static_cast</span>&lt;A&gt;(<span class="number">1</span>));	<span class="comment">//正确，显式转换</span></span><br></pre></td></tr></table></figure>
<h4 id="22-析构函数"><a class="markdownIt-Anchor" href="#22-析构函数"></a> 2.2 析构函数</h4>
<h4 id="23-拷贝构造函数"><a class="markdownIt-Anchor" href="#23-拷贝构造函数"></a> 2.3 拷贝构造函数</h4>
<h4 id="24-拷贝赋值构造函数"><a class="markdownIt-Anchor" href="#24-拷贝赋值构造函数"></a> 2.4 拷贝赋值构造函数</h4>
<h4 id="25-移动析构函数"><a class="markdownIt-Anchor" href="#25-移动析构函数"></a> 2.5 移动析构函数</h4>
<h4 id="26-移动赋值析构函数"><a class="markdownIt-Anchor" href="#26-移动赋值析构函数"></a> 2.6 移动赋值析构函数</h4>
<hr />
<h3 id="3-访问控制与封装"><a class="markdownIt-Anchor" href="#3-访问控制与封装"></a> 3. 访问控制与封装</h3>
<h4 id="31-访问权限控制"><a class="markdownIt-Anchor" href="#31-访问权限控制"></a> 3.1 访问权限控制</h4>
<p><code>C++</code>使用访问说明符加强类的封装性，一个类可包含多个访问说明符，一种访问说明符可出现多次</p>
<p>访问说明符：</p>
<ul>
<li><code>public</code>：说明符后的成员在整个程序内可被访问，用于<mark>提供接口</mark></li>
<li><code>private</code>：说明符后的成员只能被所在类的成员函数访问，用于<mark>封装实现细节</mark></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"><span class="comment">//public后的为开放接口，此处为构造函数和一些功能函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s,<span class="type">unsigned</span> n,<span class="type">double</span> p)</span><br><span class="line">        :<span class="built_in">bookNo</span>(s),<span class="built_in">units_sold</span>(n),<span class="built_in">revenue</span>(p*n)&#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream&amp;);</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookNo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="comment">//private后的为类内的成员变量和函数，不能被外部调用</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> units_sold ? revenue/units_sold : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>类的关键字</strong>也会影响类的访问控制权限。类关键字有两个，<code>struct</code>和<code>class</code>。二者都可用于类的定义，且只有默认的访问权限不同，其余完全一致。这两个关键字所影响的访问权限为类中<strong>第一个访问说明符</strong>之前定义的成员。</p>
<p><code>struct</code>关键字定义的类，在定义第一个访问说明符之前的成员是<code>public</code>的</p>
<p><code>class</code>关键字定义的类，在定义第一个访问说明符之前的成员是<code>private</code>的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test2</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test1 t1;</span><br><span class="line">    Test2 t2;</span><br><span class="line">    std::cout &lt;&lt; t1.a &lt;&lt; std::endl;			<span class="comment">//无法访问，是private</span></span><br><span class="line">    std::cout &lt;&lt; t2.a &lt;&lt; std::endl;			<span class="comment">//可以访问，是public</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="32-友元"><a class="markdownIt-Anchor" href="#32-友元"></a> 3.2 友元</h4>
<p>类可以允许其他类或者函数访问它的私有成员，只需要将其他类或者函数使用<code>friend</code>关键字设置为其友元。</p>
<p>友元声明必须在类的内部，并且位置不限，不受所在区域访问控制级别的约束和限制</p>
<p>友元声明最好在类定义开始或者结束的位置统一声明，这样代码更加简明</p>
<h5 id="友元函数"><a class="markdownIt-Anchor" href="#友元函数"></a> 友元函数</h5>
<p>将需要定义为友元函数的函数在要访问的类中加上<code>friend</code>关键字重新声明即可</p>
<h6 id="类外函数为友元函数"><a class="markdownIt-Anchor" href="#类外函数为友元函数"></a> <strong>类外函数为友元函数</strong></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s,<span class="type">unsigned</span> n,<span class="type">double</span> p)</span><br><span class="line">        :<span class="built_in">bookNo</span>(s),<span class="built_in">units_sold</span>(n),<span class="built_in">revenue</span>(p*n)&#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream&amp;);</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookNo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> units_sold ? revenue/units_sold : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//此时此函数会报错，因为不是类的成员函数，但是访问了类的私有成员变量</span></span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream &amp;is,Sales_data &amp;item)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price*item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将函数声明为友元函数，read此时可以访问类的私有成员</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;,Sales_data&amp;)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s,<span class="type">unsigned</span> n,<span class="type">double</span> p)</span><br><span class="line">        :<span class="built_in">bookNo</span>(s),<span class="built_in">units_sold</span>(n),<span class="built_in">revenue</span>(p*n)&#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream&amp;);</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookNo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> units_sold ? revenue/units_sold : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream &amp;is,Sales_data &amp;item)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price*item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>友元函数的声明只是指定函数的访问权限，而<mark>非真正的函数声明</mark>。相应友元函数的声明还需要在类外再进行一次，否则无法调用友元函数。通常将友元函数的类外声明和类本身放在同一个头文件中，防止无法调用的情况。</p>
<p>友元函数可以定义在友元声明的位置，但是友元声明不是函数声明，函数必须重新进行声明才能被正确调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;			<span class="comment">//友元声明</span></span><br><span class="line">        std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span>)</span></span>;							<span class="comment">//函数声明</span></span><br></pre></td></tr></table></figure>
<h6 id="类内函数为友元函数"><a class="markdownIt-Anchor" href="#类内函数为友元函数"></a> <strong>类内函数为友元函数</strong></h6>
<h6 id="其他类的成员函数为友元函数"><a class="markdownIt-Anchor" href="#其他类的成员函数为友元函数"></a> <strong>其他类的成员函数为友元函数</strong></h6>
<p>在声明时明确指出成员函数属于哪个类，注意<mark>依赖关系</mark></p>
<p>A类声明B类中的成员函数print为A类的友元。此时A和B的声明与定义需要按照如下顺序</p>
<ul>
<li>定义B类，并在其中声明print函数。如果函数要用到A类，则提前声明A类</li>
<li>定义A类，声明对于B类中的clear函数的友元关系</li>
<li>定义print函数，此时print函数能够访问A的私有成员</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;								<span class="comment">//A类提前声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(A&amp;)</span></span>;						<span class="comment">//只声明函数，不定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">B::print</span><span class="params">(A&amp;)</span></span>;				<span class="comment">//声明友元</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::print</span><span class="params">(A&amp;item)</span></span>&#123;					<span class="comment">//定义友元函数</span></span><br><span class="line">    std::cout &lt;&lt; item.a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="重载函数的友元"><a class="markdownIt-Anchor" href="#重载函数的友元"></a> <strong>重载函数的友元</strong></h6>
<p>重载函数本质上是不同的函数，因此如果想要将一组重载函数声明为类的友元，则需要对每一个函数<mark>分别声明</mark></p>
<h5 id="友元类"><a class="markdownIt-Anchor" href="#友元类"></a> 友元类</h5>
<p>将需要定义为友元类的类在要访问的类中加上<code>friend</code>关键字重新声明即可。</p>
<p>友元类中的成员函数可以访问此类的<mark>所有成员</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将Saler类定义为Sales_data类的友元类，Saler类的成员函数可以访问Sales_data中的所有成员</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Saler</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Saler</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Sales_data&amp;item)</span></span>&#123;</span><br><span class="line">        std::cout&lt;&lt; item.revenue &lt;&lt; item.units_sold &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>友元关系无法传递，类<code>A</code>有友元类<code>B</code>，<code>B</code>有友元类<code>C</code>，则<code>B</code>可以访问<code>A</code>的所有成员，<code>C</code>可以访问<code>B</code>的所有成员，但是<code>C</code>不能访问<code>A</code>的非公有成员。</p>
<hr />
<h3 id="4-类的作用域"><a class="markdownIt-Anchor" href="#4-类的作用域"></a> 4. 类的作用域</h3>
<p>每个类都有自己独立的作用域，在类外部访问类成员需要使用相应的运算符</p>
<p><strong>对象、指针和引用</strong>访问类内成员使用<code>.</code>或者<code>-&gt;</code>两种成员访问运算符进行访问</p>
<p><strong>类类型成员</strong>使用<code>::</code>作用域运算符进行访问，类类型成员为<mark>类内定义的函数和类型别名</mark></p>
<h5 id="在类外部定义成员"><a class="markdownIt-Anchor" href="#在类外部定义成员"></a> 在类外部定义成员</h5>
<p>即为在类外部使用<code>::</code>访问类类型成员，并进行相关操作。注意，只能在类外部定义，相应的声明必须在类内部</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在外部访问类内定义的函数和类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">    &#125; test;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">A::test it1;					<span class="comment">//访问类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::Test</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;			<span class="comment">//访问函数，此处的类作用域 包含 函数名称、参数列表和函数体</span></span><br><span class="line">    test it2;					<span class="comment">//作用域不包含返回值</span></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> test = <span class="type">double</span>;</span><br><span class="line">    <span class="function">test <span class="title">Test</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A::test <span class="title">A::Test</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;			<span class="comment">//返回类型为类类型成员，需要使用::运算符</span></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::test</span><span class="params">()</span></span>;					<span class="comment">//错误，没有在类中声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::test</span><span class="params">()</span></span>&#123;					<span class="comment">//错误，没有在类中声明</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="41-名字查找"><a class="markdownIt-Anchor" href="#41-名字查找"></a> 4.1 名字查找</h4>
<p>编译器对于类的定义分为两步处理</p>
<ul>
<li>编译类内成员的声明</li>
<li>类内成员全部可见后编译函数体</li>
</ul>
<p>因此，类中的任意成员函数可以调用类中定义的所有名字。但是注意，<strong>类内成员声明中使用的名字必须在使用前可见</strong></p>
<h5 id="类成员声明中的名字查找"><a class="markdownIt-Anchor" href="#类成员声明中的名字查找"></a> 类成员声明中的名字查找</h5>
<p>对于类成员声明中的名字，编译器首先在类作用域内查找，如果找不到，则向类外层作用域中查找，以此类推，如果最终没有找到，则报错</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Money;</span><br><span class="line">string bal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span></span>&#123;			<span class="comment">//返回值的Money为外部定义的名字</span></span><br><span class="line">        <span class="keyword">return</span> bal;				<span class="comment">//bal为内部定义的名字，不是外部的</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    Money bal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在类中，如果一个类成员声明首先使用了外层作用域中的名字，且此名字为一种类型，则之后类中声明的同名类型不会覆盖同名外部名字，只会对其后的其他声明和定义起作用。注意此处可能产生的错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string Money;</span><br><span class="line">string bal;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span></span>&#123;				<span class="comment">//此处的Money为外部定义的Money</span></span><br><span class="line">        Money a;					<span class="comment">//此处的Money为内部定义的Money</span></span><br><span class="line">        <span class="keyword">return</span> a;					<span class="comment">//此时会出错，类型不匹配</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> Money;				<span class="comment">//此处和之后的Money为内部定义的Money</span></span><br><span class="line">    Money bal = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最好将类型名的定义放置在类的开始处，防止可能产生的错误</p>
<h5 id="类成员定义中的名字查找"><a class="markdownIt-Anchor" href="#类成员定义中的名字查找"></a> 类成员定义中的名字查找</h5>
<p>类成员函数定义中使用的名字的查找过程如下</p>
<ul>
<li>首先在成员函数内查找该名字的声明</li>
<li>成员函数内没有找到，则在类内进行查找，查找所有的类成员</li>
<li>如果类内也没有找到，则在类外（成员函数定义之前）的作用域中查找</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;							<span class="comment">//覆盖了外部的a</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">(<span class="type">int</span> a)</span></span>;					</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; a &lt;&lt; std::endl;	<span class="comment">//访问类内的a,a = 1</span></span><br><span class="line">        std::cout &lt;&lt; ::a &lt;&lt; std::endl;	<span class="comment">//使用::访问全局作用域中的a,a = 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::test1</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;		<span class="comment">//a为函数内声明的局部变量，是形参</span></span><br><span class="line">    std::cout &lt;&lt; b &lt;&lt; std::endl;		<span class="comment">//b为类外作用域，函数定义之前声明的名字,b = 2;</span></span><br><span class="line">    std::cout &lt;&lt; c &lt;&lt; std::endl;		<span class="comment">//找不到c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h3 id="5-特殊的类"><a class="markdownIt-Anchor" href="#5-特殊的类"></a> 5. 特殊的类</h3>
<h4 id="51-聚合类"><a class="markdownIt-Anchor" href="#51-聚合类"></a> 5.1 聚合类</h4>
<p>聚合类的用户可以直接访问其成员，并且具有特殊的初始化形式</p>
<p>聚合类需满足如下<strong>条件</strong></p>
<ul>
<li>所有成员的访问权限都是<code>public</code></li>
<li>没有定义任何构造函数</li>
<li>没有使用类内初始值</li>
<li>没有基类，没有<code>virtual</code>函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//典型的聚合类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>聚合类的初始化形式比较特殊，除类通用的初始化方式，还可以使用<strong>花括号包含的成员列表进行初始化</strong>(显式初始化)，类似数组的列表初始化过程，并且<strong>规则相同</strong>。初始化的过程中类成员声明顺序和初始值列表中的顺序相对应进行初始化；如果初始值列表中的元素数量少于类的成员数量，则剩余的成员执行值初始化；初始值列表中的成员个数不能多于类中的成员数量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化Data聚合类</span></span><br><span class="line">Data val = &#123;<span class="number">1</span>,<span class="number">1.2</span>&#125;;		<span class="comment">//a = 1,b = 1.2</span></span><br></pre></td></tr></table></figure>
<p>聚合类的显式初始化的问题</p>
<ul>
<li>修改类成员之后，所有初始化语句都要更新</li>
<li>将正确初始化每个对象的每个成员的责任交给了用户</li>
</ul>
<h4 id="52-字面值常量类"><a class="markdownIt-Anchor" href="#52-字面值常量类"></a> 5.2 字面值常量类</h4>
<p>字面值常量类类型属于字面值类型，可以被声明为<code>constexpr</code>的</p>
<p>字面值常量类有两种情况，符合任一种的都是字面值常量类</p>
<ul>
<li>聚合类，且数据成员都是字面值类型</li>
<li>非聚合类，但满足下述要求
<ul>
<li>数据成员都是字面值类型</li>
<li>类必须至少含有一个<code>constexpr</code>构造函数</li>
<li>如果一个数据成员含有类内初始值
<ul>
<li>此成员为内置类型，则初始值必须为常量表达式</li>
<li>此成员为类类型，则初始值必须使用成员自己的<code>constexpr</code>构造函数</li>
</ul>
</li>
<li>类必须使用析构函数的默认定义</li>
</ul>
</li>
</ul>
<p><code>constexpr</code>构造函数可以有如下三种形式</p>
<ul>
<li><code>=default</code>形式</li>
<li>删除函数的形式</li>
<li>既符合构造函数的形式（无返回语句）又符合<code>constexpr</code>函数的形式（只能有返回语句这一种可执行语句），综合来看，即函数体无任何语句。注意：可以有构造函数初始值列表</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">B</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;						<span class="comment">//构造函数初始值列表初始化</span></span><br><span class="line">    <span class="type">double</span> b = <span class="number">1.1</span>;				<span class="comment">//类内初始值，常量表达式</span></span><br><span class="line">    B c = <span class="built_in">B</span>();					<span class="comment">//类内初始值，constexpr构造函数，？</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">A</span><span class="params">()</span>:a(<span class="number">1</span>)&#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*constexpr构造函数必须初始化所有成员，使用以下三种方式</span></span><br><span class="line"><span class="comment">* - 构造函数初始值列表</span></span><br><span class="line"><span class="comment">* - 类内初始值，使用常量表达式</span></span><br><span class="line"><span class="comment">* - 类内初始值，使用类成员自己的constexpr构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> A a;				<span class="comment">//将a声明为constexpr的，并检查其是否为字面值常量类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-类的静态成员"><a class="markdownIt-Anchor" href="#6-类的静态成员"></a> 6. 类的静态成员</h3>
<p>类的静态成员只和类相关联，而不是与类对象保持关联。即类的所有对象共享此静态成员</p>
<h4 id="61-声明静态成员"><a class="markdownIt-Anchor" href="#61-声明静态成员"></a> 6.1 声明静态成员</h4>
<p>类静态成员可以是<code>public</code>或者<code>private</code>的，只要在声明时加上关键字<code>static</code>即可。</p>
<p>类静态成员包括静态数据成员，静态函数成员，二者具有相似的性质，都被对象所共享，并且与类相绑定，而不是对象。因此静态成员函数不包含<code>this</code>指针，所以静态成员函数不能声明为<code>const</code>的，也不能直接访问类内的非静态成员（隐式采用<code>this</code>指针访问）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> b;			<span class="comment">//静态数据成员</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;		<span class="comment">//静态函数成员</span></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="62-使用静态成员"><a class="markdownIt-Anchor" href="#62-使用静态成员"></a> 6.2 使用静态成员</h4>
<h5 id="静态成员的访问"><a class="markdownIt-Anchor" href="#静态成员的访问"></a> 静态成员的访问</h5>
<p>类的静态成员有如下几种访问方式</p>
<ul>
<li>
<p>作用域运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c = A::b;</span><br><span class="line">A::<span class="built_in">test</span>();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类的对象、引用或指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A t1;</span><br><span class="line">A *t2 = &amp;t1;</span><br><span class="line">A &amp;t3 = t1;</span><br><span class="line"><span class="type">int</span> a = t1.b;</span><br><span class="line">t2-&gt;<span class="built_in">test</span>();</span><br><span class="line">t3.<span class="built_in">test</span>();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>直接访问，类内部函数和表达式可以直接访问静态成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="type">int</span> b = a*<span class="number">2</span>;					<span class="comment">//直接访问</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">test2</span><span class="params">()</span></span>&#123;					<span class="comment">//直接访问</span></span><br><span class="line">        <span class="built_in">test</span>();</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="静态成员的特殊应用场景"><a class="markdownIt-Anchor" href="#静态成员的特殊应用场景"></a> 静态成员的特殊应用场景</h5>
<p>静态成员<strong>可以是不完全类型</strong>，甚至是它所属的类类型。因为静态成员在类内只声明，不定义和初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> A a;							<span class="comment">//只声明，不定义和初始化</span></span><br><span class="line">&#125;;</span><br><span class="line">A A::a = <span class="built_in">A</span>();</span><br></pre></td></tr></table></figure>
<p>静态成员<strong>可以作为默认实参</strong>，静态成员在对象创建之前就可用，且存在于整个对象的生命周期中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">int</span> = a)</span></span>;					<span class="comment">//作为默认实参</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A::test</span><span class="params">(<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="63-定义和初始化静态成员"><a class="markdownIt-Anchor" href="#63-定义和初始化静态成员"></a> 6.3 定义和初始化静态成员</h4>
<h5 id="静态成员函数"><a class="markdownIt-Anchor" href="#静态成员函数"></a> 静态成员函数</h5>
<p>类的静态成员函数可以在类内定义，也可以类似其他成员函数在类外进行定义。在类外定义静态成员函数时不用重复<code>static</code>关键字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A::test</span><span class="params">()</span></span>&#123;							<span class="comment">//不重复static关键字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="静态数据成员"><a class="markdownIt-Anchor" href="#静态数据成员"></a> 静态数据成员</h5>
<p>静态数据成员不属于任何一个类对象，因此也不应该使用构造函数初始化。一般在<mark>类的外部</mark>定义和初始化所有的静态数据成员。<code>static</code>关键字同样只能用于类内数据成员的声明，而不能用于类外数据成员的定义和初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a;						<span class="comment">//类内声明，没有定义</span></span><br><span class="line">    <span class="type">int</span> b;								<span class="comment">//声明、定义，但没有初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::a = <span class="number">1</span>;							<span class="comment">//类外定义和初始化</span></span><br></pre></td></tr></table></figure>
<p>类的静态成员也可以在类内声明和初始化，此时要求此成员必须是<code>constexpr</code>的，并且初始值必须是常量表达式。在类内初始化的静态成员，通常也需要在类外进行定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">1</span>;			<span class="comment">//类内声明和初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> A::a;						<span class="comment">//类外定义</span></span><br></pre></td></tr></table></figure>
    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>StillWater
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://cautiousnut.github.io/2022/08/31/C++%E7%B1%BB/" title="C++类">https://cautiousnut.github.io/2022/08/31/C++类/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"># 学习笔记</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/28/C++%E5%87%BD%E6%95%B0/" rel="prev" title="C++函数">
      <i class="fa fa-chevron-left"></i> C++函数
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/09/20/C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/" rel="next" title="C++字符串、向量和数组">
      C++字符串、向量和数组 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">1.</span> <span class="nav-text"> 类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%B1%BB%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.</span> <span class="nav-text"> 1. 类的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text"> 1.1 类类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.1.1.</span> <span class="nav-text"> 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-number">1.1.1.2.</span> <span class="nav-text"> 类的声明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-this%E6%8C%87%E9%92%88"><span class="nav-number">1.1.2.</span> <span class="nav-text"> 1.2 this指针</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.2.1.</span> <span class="nav-text"> 基本原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.2.2.</span> <span class="nav-text"> const成员函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%94%E5%9B%9Ethis%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.2.3.</span> <span class="nav-text"> 返回this的函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.3.</span> <span class="nav-text"> 1.3 成员函数和内联函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="nav-number">1.1.4.</span> <span class="nav-text"> 1.4 可变数据成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-%E7%B1%BB%E5%86%85%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="nav-number">1.1.5.</span> <span class="nav-text"> 1.5 类内初始值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.</span> <span class="nav-text"> 2. 特殊成员函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#21-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.1.</span> <span class="nav-text"> 2.1 构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.1.1.</span> <span class="nav-text"> 默认构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.2.1.2.</span> <span class="nav-text"> 默认构造函数的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%97%E8%A1%A8"><span class="nav-number">1.2.1.3.</span> <span class="nav-text"> 构造函数初始值列表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="nav-number">1.2.1.4.</span> <span class="nav-text"> 初始化和赋值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.2.1.5.</span> <span class="nav-text"> 成员初始化顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.1.6.</span> <span class="nav-text"> 委托构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%9A%84%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.2.1.7.</span> <span class="nav-text"> 隐式的类类型转换</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.2.</span> <span class="nav-text"> 2.2 析构函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.3.</span> <span class="nav-text"> 2.3 拷贝构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.4.</span> <span class="nav-text"> 2.4 拷贝赋值构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-%E7%A7%BB%E5%8A%A8%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.5.</span> <span class="nav-text"> 2.5 移动析构函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.6.</span> <span class="nav-text"> 2.6 移动赋值析构函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B0%81%E8%A3%85"><span class="nav-number">1.3.</span> <span class="nav-text"> 3. 访问控制与封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#31-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="nav-number">1.3.1.</span> <span class="nav-text"> 3.1 访问权限控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#32-%E5%8F%8B%E5%85%83"><span class="nav-number">1.3.2.</span> <span class="nav-text"> 3.2 友元</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.2.1.</span> <span class="nav-text"> 友元函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B1%BB%E5%A4%96%E5%87%BD%E6%95%B0%E4%B8%BA%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.2.1.1.</span> <span class="nav-text"> 类外函数为友元函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B1%BB%E5%86%85%E5%87%BD%E6%95%B0%E4%B8%BA%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.2.1.2.</span> <span class="nav-text"> 类内函数为友元函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%BA%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.2.1.3.</span> <span class="nav-text"> 其他类的成员函数为友元函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%8B%E5%85%83"><span class="nav-number">1.3.2.1.4.</span> <span class="nav-text"> 重载函数的友元</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="nav-number">1.3.2.2.</span> <span class="nav-text"> 友元类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.4.</span> <span class="nav-text"> 4. 类的作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E7%B1%BB%E5%A4%96%E9%83%A8%E5%AE%9A%E4%B9%89%E6%88%90%E5%91%98"><span class="nav-number">1.4.0.1.</span> <span class="nav-text"> 在类外部定义成员</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#41-%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE"><span class="nav-number">1.4.1.</span> <span class="nav-text"> 4.1 名字查找</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E5%A3%B0%E6%98%8E%E4%B8%AD%E7%9A%84%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE"><span class="nav-number">1.4.1.1.</span> <span class="nav-text"> 类成员声明中的名字查找</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE"><span class="nav-number">1.4.1.2.</span> <span class="nav-text"> 类成员定义中的名字查找</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%89%B9%E6%AE%8A%E7%9A%84%E7%B1%BB"><span class="nav-number">1.5.</span> <span class="nav-text"> 5. 特殊的类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#51-%E8%81%9A%E5%90%88%E7%B1%BB"><span class="nav-number">1.5.1.</span> <span class="nav-text"> 5.1 聚合类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#52-%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F%E7%B1%BB"><span class="nav-number">1.5.2.</span> <span class="nav-text"> 5.2 字面值常量类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-number">1.6.</span> <span class="nav-text"> 6. 类的静态成员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#61-%E5%A3%B0%E6%98%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-number">1.6.1.</span> <span class="nav-text"> 6.1 声明静态成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#62-%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-number">1.6.2.</span> <span class="nav-text"> 6.2 使用静态成员</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-number">1.6.2.1.</span> <span class="nav-text"> 静态成员的访问</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E7%89%B9%E6%AE%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.6.2.2.</span> <span class="nav-text"> 静态成员的特殊应用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#63-%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-number">1.6.3.</span> <span class="nav-text"> 6.3 定义和初始化静态成员</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.3.1.</span> <span class="nav-text"> 静态成员函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="nav-number">1.6.3.2.</span> <span class="nav-text"> 静态数据成员</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="StillWater"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">StillWater</p>
  <div class="site-description" itemprop="description">业精于勤荒于嬉，行成于思毁于随</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021-7-16 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">StillWater</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">101k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:32</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
