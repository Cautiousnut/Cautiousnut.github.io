<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="C++变量和基本类型  1. 重定向问题  C++primer中提到可以使用&gt;和&lt;实现文件重定向，但是实测在powershell中是无法使用的。但可以使用其他命令代替，具体内容可参考如下链接。 Windows下的重定向 - 叶家星 - 博客园 (cnblogs.com) (55条消息) Windows PowerShell的“管道”以及对可执行文件的文件重定向_fjjaylz的博客-">
<meta property="og:type" content="article">
<meta property="og:title" content="C++变量和基本类型">
<meta property="og:url" content="https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/index.html">
<meta property="og:site_name" content="Cautiousnut">
<meta property="og:description" content="C++变量和基本类型  1. 重定向问题  C++primer中提到可以使用&gt;和&lt;实现文件重定向，但是实测在powershell中是无法使用的。但可以使用其他命令代替，具体内容可参考如下链接。 Windows下的重定向 - 叶家星 - 博客园 (cnblogs.com) (55条消息) Windows PowerShell的“管道”以及对可执行文件的文件重定向_fjjaylz的博客-">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.staticaly.com/gh/ZhuHuixj/Image@main/img/image-20220904230932730.png">
<meta property="og:image" content="https://cdn.staticaly.com/gh/ZhuHuixj/Image@main/img/image-20220904224408106.png">
<meta property="article:published_time" content="2022-08-27T14:21:00.000Z">
<meta property="article:modified_time" content="2022-09-26T15:08:50.835Z">
<meta property="article:author" content="Cautiousnut">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.staticaly.com/gh/ZhuHuixj/Image@main/img/image-20220904230932730.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>C++变量和基本类型</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/probberechts">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2022/08/28/C++%E5%87%BD%E6%95%B0/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2022/04/01/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%AD/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/&text=C++变量和基本类型"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/&title=C++变量和基本类型"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/&is_video=false&description=C++变量和基本类型"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=C++变量和基本类型&body=Check out this article: https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/&title=C++变量和基本类型"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/&title=C++变量和基本类型"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/&title=C++变量和基本类型"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/&title=C++变量和基本类型"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/&name=C++变量和基本类型&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/&t=C++变量和基本类型"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text"> C++变量和基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%87%8D%E5%AE%9A%E5%90%91%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.1.</span> <span class="toc-text"> 1. 重定向问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.0.2.</span> <span class="toc-text"> 2. 初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#21-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="toc-number">1.0.2.1.</span> <span class="toc-text"> 2.1 初始化与赋值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22-%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.0.2.2.</span> <span class="toc-text"> 2.2 列表初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#23-%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.0.2.3.</span> <span class="toc-text"> 2.3 默认初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#24-%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.0.2.4.</span> <span class="toc-text"> 2.4 值初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#25-%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.0.2.5.</span> <span class="toc-text"> 2.5 直接初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#26-%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.0.2.6.</span> <span class="toc-text"> 2.6 拷贝初始化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89"><span class="toc-number">1.0.3.</span> <span class="toc-text"> 3. 声明与定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%BC%95%E7%94%A8"><span class="toc-number">1.0.4.</span> <span class="toc-text"> 4. 引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%8C%87%E9%92%88"><span class="toc-number">1.0.5.</span> <span class="toc-text"> 5. 指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-const%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">1.0.6.</span> <span class="toc-text"> 6. const限定符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-constexpr%E5%92%8C%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.0.7.</span> <span class="toc-text"> 7. constexpr和常量表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">1.0.8.</span> <span class="toc-text"> 8. 类型别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-auto%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">1.0.9.</span> <span class="toc-text"> 9. auto类型说明符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-decltype%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="toc-number">1.0.10.</span> <span class="toc-text"> 10. decltype类型指示符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.11.</span> <span class="toc-text"> 11. 自定义数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.0.12.</span> <span class="toc-text"> 12. 头文件保护预处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.0.13.</span> <span class="toc-text"> 参考</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        C++变量和基本类型
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Cautiousnut</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-08-27T14:21:00.000Z" class="dt-published" itemprop="datePublished">2022-08-27</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/C/">C++</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h2 id="c变量和基本类型"><a class="markdownIt-Anchor" href="#c变量和基本类型"></a> C++变量和基本类型</h2>
<h4 id="1-重定向问题"><a class="markdownIt-Anchor" href="#1-重定向问题"></a> 1. 重定向问题</h4>
<ul>
<li><code>C++primer</code>中提到可以使用<code>&gt;</code>和<code>&lt;</code>实现文件重定向，但是实测在<code>powershell</code>中是无法使用的。但可以使用其他命令代替，具体内容可参考如下链接。</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yejiaxing-01/p/12570763.html">Windows下的重定向 - 叶家星 - 博客园 (cnblogs.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/fjjaylz/article/details/86663013">(55条消息) Windows PowerShell的“管道”以及对可执行文件的文件重定向_fjjaylz的博客-CSDN博客_powershell 文件重定向</a></li>
</ul>
<h4 id="2-初始化"><a class="markdownIt-Anchor" href="#2-初始化"></a> 2. 初始化</h4>
<h5 id="21-初始化与赋值"><a class="markdownIt-Anchor" href="#21-初始化与赋值"></a> 2.1 初始化与赋值</h5>
<ul>
<li>初始化不是赋值</li>
<li>初始化是创建变量时赋予一个初始值。</li>
<li>赋值是把对象的当前值擦除，用一个新值代替。</li>
</ul>
<h5 id="22-列表初始化"><a class="markdownIt-Anchor" href="#22-列表初始化"></a> 2.2 列表初始化</h5>
<p>使用<code>&#123;&#125;</code>括起来的列表进行初始化，可以是直接初始化，也可以是拷贝初始化</p>
<p>当列表初始化应用于内置类型，且此时存在丢失信息的风险时，编译器会报错，注意与普通的初始化过程的对比</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b&#123;a&#125;,c = &#123;a&#125;;		<span class="comment">//报错</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">d</span><span class="params">(a)</span>,e </span>= a;			<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.staticaly.com/gh/ZhuHuixj/Image@main/img/image-20220904230932730.png" alt="image-20220904230932730" /></p>
<h5 id="23-默认初始化"><a class="markdownIt-Anchor" href="#23-默认初始化"></a> 2.3 默认初始化</h5>
<ul>
<li>
<p>变量定义时未指定初值则会进行默认初始化。</p>
</li>
<li>
<p>内置类型和复合类型（数组和指针）</p>
<ul>
<li>
<p>定义于块(函数作用域、类作用域)外初始化为0</p>
</li>
<li>
<p>定义于块内不会初始化，为未定义，无法预知结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">double</span> a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;			<span class="comment">//函数外，初始化为0</span></span><br><span class="line">    std::cout &lt;&lt; b &lt;&lt; std::endl;			<span class="comment">//函数内，编译器等运行环境决定</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.staticaly.com/gh/ZhuHuixj/Image@main/img/image-20220904224408106.png" alt="image-20220904224408106" /></p>
</li>
</ul>
</li>
<li>
<p>类类型调用类的默认构造函数进行初始化</p>
</li>
</ul>
<h5 id="24-值初始化"><a class="markdownIt-Anchor" href="#24-值初始化"></a> 2.4 值初始化</h5>
<p>值初始化发生于以下三种情况</p>
<ul>
<li>数组初始化过程中提供的初始值少于数组的大小</li>
<li>不使用初始值定义局部静态变量</li>
<li>显式书写形如<code>T()</code>的表达式请求值初始化</li>
</ul>
<p>值初始化的操作</p>
<ul>
<li>对于内置类型和复合类型，初始化为零</li>
<li>对于数组，值初始化每个元素</li>
<li>对于类类型，调用默认构造函数</li>
</ul>
<h5 id="25-直接初始化"><a class="markdownIt-Anchor" href="#25-直接初始化"></a> 2.5 直接初始化</h5>
<p>不使用等号进行初始化，而是直接在类型右侧紧跟<code>()</code>或者<code>&#123;&#125;</code>来进行初始化</p>
<p>使用直接初始化的类型要有<code>()</code>或<code>&#123;&#125;</code>内相应格式的构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> b&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function">string <span class="title">c</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="26-拷贝初始化"><a class="markdownIt-Anchor" href="#26-拷贝初始化"></a> 2.6 拷贝初始化</h5>
<p>使用等号进行初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">string c = <span class="built_in">string</span>(<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="3-声明与定义"><a class="markdownIt-Anchor" href="#3-声明与定义"></a> 3. 声明与定义</h4>
<ul>
<li>
<p>声明：规定变量的类型和名字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;		<span class="comment">//初始化后成为定义，且不能在函数体内初始化</span></span><br><span class="line"><span class="comment">//变量可以声明多次，但只能定义一次</span></span><br><span class="line"><span class="comment">//例</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i = <span class="number">10</span>;	<span class="comment">//定义，正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i = <span class="number">10</span>;			<span class="comment">//错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义：规定变量的类型、名字，并申请存储空间，还可能赋初值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="4-引用"><a class="markdownIt-Anchor" href="#4-引用"></a> 4. 引用</h4>
<ul>
<li>
<p>引用必须初始化，且无法进行赋值，即初始化之后无法重新绑定到其他对象上。</p>
</li>
<li>
<p>引用不是对象，它只是对象的别名，引用的类型要和与之绑定的对象严格匹配。</p>
</li>
<li>
<p>字面值和表达式的计算结果不是对象，因此没有相应的引用。也可理解为，引用是左值引用，即引用的对象必须是一个左值。</p>
</li>
<li>
<p>引用必须绑定在对象上，不能定义引用的引用；引用不是对象，因此也没有引用的指针；指针是对象，因此有指针的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *b = &amp;a;</span><br><span class="line">    <span class="type">int</span> *&amp;c = b;					<span class="comment">//指针的引用，注意类型的匹配</span></span><br><span class="line">    std::cout &lt;&lt; *c &lt;&lt; std::endl;	<span class="comment">//输出10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>前述引用类型和与之绑定的对象类型要严格匹配。但是有两个例外</p>
<ul>
<li>
<p>初始化常量引用时，允许任意表达式作为初始值，只要该表达式结果能够转换为引用的类型即可。允许常量引用绑定非常亮的对象、字面值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b = a;			<span class="comment">//正确，非常量可以转换为常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c = <span class="number">1</span>;			<span class="comment">//正确，字面值常量可以转换为常量对象</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;d = b * <span class="number">2</span>;		<span class="comment">//正确，运算结果可转换</span></span><br><span class="line"><span class="type">int</span> &amp;e = b * <span class="number">2</span>;				<span class="comment">//错误，不是常量引用，不能引用字面值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="5-指针"><a class="markdownIt-Anchor" href="#5-指针"></a> 5. 指针</h4>
<ul>
<li>
<p>指针是对象，指针的类型与它所指向的类型必须匹配。</p>
</li>
<li>
<p>使用字面值<code>nullptr</code>初始化指针得到空指针，<code>nullptr</code>可以转换为任何指针类型。</p>
</li>
<li>
<p><code>void*</code>指针可以指向任意类型的对象，不能直接操作<code>void*</code>指针指向的对象，因为无法确认对象的类型。</p>
</li>
<li>
<p>使用<code>*</code>，<code>&amp;</code>等定义变量时，二者只是类型修饰符，是声明符的一部分，只作用于其后所接的第一个变量名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1024</span>,*p = &amp;i,&amp;r = i;		<span class="comment">//i为int型的数，p是int型指针，r是int型引用</span></span><br><span class="line"><span class="type">int</span> *p1,p2;							<span class="comment">//p1为int型指针，p2为int型变量</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>指针类型和所指对象类型不匹配的两种情况</p>
<ul>
<li>
<p>允许指向常量的指针指向一个非常量对象（类似常量引用）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *b = &amp;a;				<span class="comment">//正确,但是不能用b改变a的值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="6-const限定符"><a class="markdownIt-Anchor" href="#6-const限定符"></a> 6. const限定符</h4>
<ul>
<li>
<p><code>const</code>对象一经创建就无法修改，因此必须在定义时进行初始化</p>
<ul>
<li>
<p>对于有默认构造函数的类类型，可以使用默认初始化的方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> Test t1;				<span class="comment">//正确，使用默认初始化方式，调用默认构造函数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对于其他类型，必须显式的进行初始化，即使用除了默认初始化之外的其他方式初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a;				<span class="comment">//错误，不能使用默认初始化，必须显式初始化</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>在<code>const</code>类型的对象上进行的操作不能改变其内容，否则会出错。</p>
</li>
<li>
<p>默认情况下，<code>const</code>对象仅在一个文件中有效，因为<code>const</code>对象在编译时会被替换为其值，编译器必须知道它的初始值，因此每个文件中都必须有其定义。并且当多个文件中出现同名的<code>const</code>变量时，等同于在不同文件中定义了独立的变量。</p>
</li>
<li>
<p>想要在文件之间共享<code>const</code>变量，可以使用<code>extern</code>关键字进行声明和定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.cpp中定义const变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = <span class="built_in">fcn</span>();</span><br><span class="line"><span class="comment">//b.h头文件中声明，即可直接使用</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize;	<span class="comment">//与a.cpp中的是同一个变量</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>常量引用，即把引用绑定到常量对象上。此时显然不能对被引用的常量对象进行修改操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b = a;		<span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;c = a;				<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对<code>const</code>的引用可以引用一个非<code>const</code>对象，此时无法通过引用修改对象，但是可以通过其他方式进行修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;				<span class="comment">//i是可以修改的</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;a = i;		<span class="comment">//不能通过a修改i对象</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>指向常量的指针和常量指针</p>
<ul>
<li>
<p>指向常量的指针，不能用于修改其所指对象的值。对象不是常量时，其值可以通过其他方式修改。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *b = &amp;a;		<span class="comment">//此处即为指向常量的指针，此时不能通过b修改a的值</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>常量指针。指针是对象，可以把自身定为常量。常量指针要满足普通常量的要求（初始化等特性）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> b = &amp;a;		<span class="comment">//此时b为常量指针，b的内容无法改变，但是a可以改变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> d = &amp;c;	<span class="comment">//指向常量对象的常量指针</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>顶层<code>const</code>和底层<code>const</code>。顶层<code>const</code>表示指针本身是常量，底层<code>const</code>表示指针所指对象是常量。执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层<code>const</code>资格，或者两个对象的数据类型可以相互转换。非常量可以转换为常量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> b = &amp;a;		<span class="comment">//既是底层const又是顶层const</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* d = &amp;a;				<span class="comment">//底层const</span></span><br><span class="line"><span class="type">int</span> *e = b;						<span class="comment">//错误，b包含底层const定义，而c没有</span></span><br><span class="line">d = b;							<span class="comment">//正确，b,c都包含底层const定义</span></span><br><span class="line">d = &amp;c;							<span class="comment">//正确，int*可以转换为const int *</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="7-constexpr和常量表达式"><a class="markdownIt-Anchor" href="#7-constexpr和常量表达式"></a> 7. constexpr和常量表达式</h4>
<ul>
<li>
<p>常量表达式是指值不会改变并且在编译过程中就可以得到计算结果的表达式。如：字面值、用常量表达式初始化的<code>const</code>对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;					<span class="comment">//a不是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="built_in">get_size</span>();	<span class="comment">//b不是常量表达式，编译时无法确定</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>constexpr</code>用于声明常量表达式变量，声明之后，编译器就会在编译时验证该变量是否为常量表达式。声明为<code>constexpr</code>的变量一定是常量，并且必须用常量表达式初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">1</span>;		<span class="comment">//1是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> b = <span class="built_in">size</span>();	<span class="comment">//此时size需要是一个constexpr函数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>声明<code>constexpr</code>时的类型必须是字面值类型。字面值类型包括<code>算数类型、引用、指针、字面值常量类、枚举</code>。</p>
</li>
<li>
<p><code>constexpr</code>指针</p>
<ul>
<li>
<p><code>constexpr</code>指针初始值必须是<code>nullptr</code>或者<code>0</code>，或者是存储于固定地址的对象。函数体内的变量存储于非固定地址，定义于所有函数体制外的对象存储于固定地址。</p>
</li>
<li>
<p><code>constexpr</code>指针中<code>constexpr</code>限定符只对指针有效，与指针所指对象无关。使用<code>constexpr</code>定义变量相当于顶层<code>const</code>，定义指针相当于常量指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *a = <span class="literal">nullptr</span>;		<span class="comment">//指向常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *b = <span class="literal">nullptr</span>;	<span class="comment">//常量指针</span></span><br><span class="line"><span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span>*c = &amp;p;	<span class="comment">//指向常量的常量指针,p可以不是常量</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="8-类型别名"><a class="markdownIt-Anchor" href="#8-类型别名"></a> 8. 类型别名</h4>
<ul>
<li>
<p>两种：<code>typedef</code>和<code>using(别名声明)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> a;					<span class="comment">//a是int的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> a b,*c;					<span class="comment">//b是int的同义词，c是int*的同义词，*为类型修饰，表									  示是指针类型</span></span><br><span class="line"><span class="comment">//使用 出现原类型的地方直接使用别名代替即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">using</span> a = <span class="type">int</span>;					<span class="comment">//a是int的同义词</span></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">a b = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意类型别名的理解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *ptr;</span><br><span class="line"><span class="type">const</span> ptr a = <span class="number">0</span>;			<span class="comment">//a是常量指针，指向char类型的对象</span></span><br><span class="line"><span class="type">const</span> ptr *b;				<span class="comment">//ps是一个指针，指向对象是指向char的常量指针</span></span><br><span class="line"><span class="comment">//ptr是整体，表示指向char的指针，此时不能直接将char*还原到语句中来理解。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-auto类型说明符"><a class="markdownIt-Anchor" href="#9-auto类型说明符"></a> 9. auto类型说明符</h4>
<ul>
<li>
<p><code>auto</code>由编译器分析表达式确定类型。因此<code>auto</code>定义的变量必须具有初始值，否则编译器无法分析。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = b + c;			<span class="comment">//根据b和c的类型确定a的类型</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当引用类型作为<code>auto</code>的初始值时，编译器会将引用对象的类型作为<code>auto</code>的类型。</p>
</li>
<li>
<p><code>auto</code>会忽略顶层<code>const</code>，保留底层<code>const</code>。希望<code>auto</code>是顶层<code>const</code>，要明确指出。<code>auto</code>为引用类型时，引用的相应规则仍旧适用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i,&amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;		<span class="comment">//int</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;		<span class="comment">//cr是ci的别名，因此还是int</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;		<span class="comment">//int</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;		<span class="comment">//ci为常量，&amp;ci表示指向常量的指针的值(底层const)，const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;g = ci;		<span class="comment">//const int，整形常量引用</span></span><br><span class="line"><span class="keyword">auto</span> &amp;h = <span class="number">42</span>;		<span class="comment">//错误</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;j = <span class="number">42</span>;	<span class="comment">//正确，常量引用，const int</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> f = ci;		<span class="comment">//明确指出，ci是int，f即为const int</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用<code>auto</code>一条语句声明多个变量时，因为一条声明语句只能有一个基本数据类型，因此该语句中所有变量的类型必须一致。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">0</span>,b = <span class="number">3.14</span>;		<span class="comment">//错误，a和b的类型不一致</span></span><br><span class="line"><span class="keyword">auto</span> &amp;m = ci,*p = &amp;ci;		<span class="comment">//正确，m为常量引用，p为指向常量的指针</span></span><br><span class="line"><span class="keyword">auto</span> &amp;n = i,*p2 = &amp;ci;		<span class="comment">//错误，n为int，p2为const int</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="10-decltype类型指示符"><a class="markdownIt-Anchor" href="#10-decltype类型指示符"></a> 10. decltype类型指示符</h4>
<ul>
<li>
<p>用于希望从表达式类型推断要定义的变量类型但是不想用该表达式的值初始化的情形。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x;			<span class="comment">//f的返回类型即为sum的类型</span></span><br><span class="line"><span class="comment">//编译器不会实际调用函数f，只会获取f的返回值的类型作为sum的类型</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果<code>decltype</code>使用的表达式是一个变量，则会返回变量的类型，包括顶层<code>const</code>和引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">0</span>,&amp;b = a;</span><br><span class="line"><span class="keyword">decltype</span>(a) x = <span class="number">0</span>;			<span class="comment">//const int</span></span><br><span class="line"><span class="keyword">decltype</span>(b) y = x;			<span class="comment">//const int &amp;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果<code>decltype</code>使用的表达式不是一个变量，则会返回表达式结果对应的类型。当表达式的结果对象能作为一条赋值语句的左值时，一般返回引用类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;*p = &amp;i,&amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r<span class="number">+0</span>) b;	<span class="comment">//r是引用类型，直接替换为i即1，相加之后还是整形，因此b是int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c;		<span class="comment">//*p是一个可赋值的左值，返回引用类型，即int&amp;，此时要初始化</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意。对于<code>decltype</code>所用表达式，如果变量名加上额外的一对或多对括号，则编译器会将其当做表达式。并且是一种可以作为赋值语句左值的特殊表达式，因此会返回引用类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>((i)) a;		<span class="comment">//int &amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) b;			<span class="comment">//int</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="11-自定义数据类型"><a class="markdownIt-Anchor" href="#11-自定义数据类型"></a> 11. 自定义数据类型</h4>
<ul>
<li>类内数据成员可以进行显式初始化，如果没有，则会被默认初始化。</li>
<li>类通常被定义在头文件中，而且类所在头文件的名字应该与类的名字一样。</li>
<li>头文件通常包含只能定义一次的实体，如<code>类、const、constexpr变量</code>，还包含用到的其他头文件</li>
</ul>
<h4 id="12-头文件保护预处理"><a class="markdownIt-Anchor" href="#12-头文件保护预处理"></a> 12. 头文件保护预处理</h4>
<ul>
<li>
<p><code>#define</code>把一个名字设定为预处理变量，设定后表示此变量已定义</p>
</li>
<li>
<p><code>#ifdef</code>如果预处理变量已经定义，则执行此后的程序，直到<code>#endif</code></p>
</li>
<li>
<p><code>#ifndef</code>如果预处理变量没有定义，则执行此后的程序，直到<code>#endif</code></p>
</li>
<li>
<p>用预处理功能防止头文件重复包含.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在头文件中加入如下预处理代码，可防止此头文件被多次引入</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SALES_DATA_H		<span class="comment">//此时未定义，执行之后的程序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SALES_DATA_H		<span class="comment">//定义，预处理变量名一般全部大写</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span>			</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;			</span><br><span class="line">    std::string a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//之后如果再一次包含此头文件，则ifndef会为假，之后到endif的部分会被直接忽略</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr />
<h4 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h4>
<ul>
<li>本文内容主要是<code>C++ primer</code>第二章内容的总结</li>
</ul>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text"> C++变量和基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%87%8D%E5%AE%9A%E5%90%91%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.1.</span> <span class="toc-text"> 1. 重定向问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.0.2.</span> <span class="toc-text"> 2. 初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#21-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="toc-number">1.0.2.1.</span> <span class="toc-text"> 2.1 初始化与赋值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22-%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.0.2.2.</span> <span class="toc-text"> 2.2 列表初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#23-%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.0.2.3.</span> <span class="toc-text"> 2.3 默认初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#24-%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.0.2.4.</span> <span class="toc-text"> 2.4 值初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#25-%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.0.2.5.</span> <span class="toc-text"> 2.5 直接初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#26-%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.0.2.6.</span> <span class="toc-text"> 2.6 拷贝初始化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89"><span class="toc-number">1.0.3.</span> <span class="toc-text"> 3. 声明与定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%BC%95%E7%94%A8"><span class="toc-number">1.0.4.</span> <span class="toc-text"> 4. 引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%8C%87%E9%92%88"><span class="toc-number">1.0.5.</span> <span class="toc-text"> 5. 指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-const%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">1.0.6.</span> <span class="toc-text"> 6. const限定符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-constexpr%E5%92%8C%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.0.7.</span> <span class="toc-text"> 7. constexpr和常量表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">1.0.8.</span> <span class="toc-text"> 8. 类型别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-auto%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">1.0.9.</span> <span class="toc-text"> 9. auto类型说明符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-decltype%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="toc-number">1.0.10.</span> <span class="toc-text"> 10. decltype类型指示符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.11.</span> <span class="toc-text"> 11. 自定义数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.0.12.</span> <span class="toc-text"> 12. 头文件保护预处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.0.13.</span> <span class="toc-text"> 参考</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/&text=C++变量和基本类型"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/&title=C++变量和基本类型"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/&is_video=false&description=C++变量和基本类型"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=C++变量和基本类型&body=Check out this article: https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/&title=C++变量和基本类型"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/&title=C++变量和基本类型"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/&title=C++变量和基本类型"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/&title=C++变量和基本类型"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/&name=C++变量和基本类型&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://cautiousnut.github.io/2022/08/27/C++%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/&t=C++变量和基本类型"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    Cautiousnut
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/probberechts">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
